Chapter 7. Advanced Editing





This chapter introduces you to some of the more advanced capabilities of the vi and ex editors. You should be reasonably familiar with the material presented in the earlier chapters of this book before you start working with the concepts presented here.

We have divided this chapter into five parts. The first part discusses a number of ways to set options that allow you to customize your editing environment. You’ll learn how to use the set command and how to create a number of different editing environments using .exrc files.

The second part discusses how you can execute Unix commands from within vi, and how you can use vi to filter text through Unix commands.

The third part discusses various ways to save long sequences of commands by reducing them to abbreviations, or even to commands that use only one keystroke (this is called mapping keys). It also includes a section on @-functions, which allow you to store command sequences in a buffer.

The fourth part discusses the use of ex scripts from the Unix command line or from within shell scripts. Scripting provides a powerful way to make repetitive edits.

The fifth part discusses some features of vi that are especially useful to programmers. vi has options that control line indentation and an option to display invisible characters (specifically tabs and newlines). There are search commands that are useful with program code blocks or with C functions.





Customizing vi





vi operates differently on various terminals. On modern Unix systems, vi gets operating instructions about your terminal type from the terminfo terminal database. (On older systems, vi uses the original termcap database.)[29]

There are also a number of options that you can set from within vi that affect how it operates. For example, you can set a right margin that will cause vi to wrap lines automatically, so you don’t need to hit ENTER.

You can change options from within vi by using the ex command :set. In addition, whenever vi is started up, it reads a file in your home directory called .exrc for further operating instructions. By placing :set commands in this file, you can modify the way vi acts whenever you use it.

You can also set up .exrc files in local directories to initialize various options that you want to use in different environments. For example, you might define one set of options for editing English text, but another set for editing source programs. The .exrc file in your home directory will be executed first, and then the one in your current directory.

Finally, any commands stored in the environment variable EXINIT will be executed by vi on startup. The settings in EXINIT take precedence over those in the home directory.exrc file.





The :set Command





There are two types of options that can be changed with the :set command: toggle options, which are either on or off, and options that take a numeric or string value (such as the location of a margin or the name of a file).

Toggle options may be on or off by default. To turn a toggle option on, the command is:

:setoption

To turn a toggle option off, the command is:

:set nooption

For example, to specify that pattern searches should ignore case, type:

:set ic

If you want vi to return to being case-sensitive in searches, give the command:

:set noic

Some options have a value assigned to them. For example, the window option sets the number of lines shown in the screen’s “window.” You set values for these options with an equals sign (=):

:set window=20

During a vi session, you can check which options vi is using. The command:

:set all

displays the complete list of options, including options that you have set and defaults that vi has “chosen.”

The display should look something like this:[30]

autoindent nomodelines noshowmode autoprint nonumber noslowopen noautowrite nonovice tabstop=8 beautify nooptimize taglength=0 directory=/var/tmp paragraphs=IPLPPPQPP LIpplpipnpbp tags=tags /usr/lib/tags noedcompatible prompt tagstack errorbells noreadonly term=vt102 noexrc redraw noterse flash remap timeout hardtabs=8 report=5 ttytype=vt102 noignorecase scroll=11 warn nolisp sections=NHSHH HUuhsh+c window=23 nolist shell=/bin/ksh wrapscan magic shiftwidth=8 wrapmargin=0 nomesg showmatch nowriteany

You can find out the current value of any individual option by name, using the command:

:setoption?

The command:

:set

shows options that you have specifically changed, or set, either in your .exrc file or during the current session.

For example, the display might look like this:

number sect=AhBhChDh window=20 wrapmargin=10





The .exrc File





The .exrc file that controls your own vi environment is in your home directory (the directory you are in when you first log on). You can modify the .exrc file with the vi editor, just as you can any other text file.

If you don’t yet have an .exrc file, simply use vi to create one. Enter into this file the set, ab, and map commands that you want to have in effect whenever you use vi or ex. (ab and map are discussed later in this chapter.) A sample .exrc file might look like this:

set nowrapscan wrapmargin=7 set sections=SeAhBhChDh nomesg map q :w^M:n^M map v dwElp ab ORA O'Reilly Media, Inc.

Since the file is actually read by ex before it enters visual mode (vi), commands in .exrc need not have a preceding colon.





Alternate Environments





In addition to reading the .exrc file in your home directory, you can allow vi to read a file called .exrc in the current directory. This lets you set options that are appropriate to a particular project.

In all modern versions of vi, you have to first set the exrc option in your home directory’s .exrc file before vi will read the .exrc file in the current directory:

set exrc

This mechanism prevents other people from placing, in your working directory, an .exrc file whose commands might jeopardize the security of your system.[31]

For example, you might want to have one set of options in a directory mainly used for programming:

set number autoindent sw=4 terse set tags=/usr/lib/tags

and another set of options in a directory used for text editing:

set wrapmargin=15 ignorecase

Note that you can set certain options in the .exrc file in your home directory and unset them in a local directory.

You can also define alternate vi environments by saving option settings in a file other than .exrc and reading in that file with the :so command. (so is short for source.)

For example:

:so .progoptions

Local .exrc files are also useful for defining abbreviations and key mappings (described later in this chapter). When we write a book or manual, we save all abbreviations to be used in that book in an .exrc file in the directory in which the book is being created.





Some Useful Options





As you can see when you type :set all, there are an awful lot of options that can be set. Many of them are used internally by vi and aren’t usually changed. Others are important in certain cases but not in others (for example, noredraw and window can be useful over a cross-continental ssh session). Table B-1 in the section Solaris vi Options contains a brief description of each option. We recommend that you take some time to play with setting options. If an option looks interesting, try setting it (or unsetting it) and watch what happens while you edit. You may find some surprisingly useful tools.

As discussed earlier in the section Movement Within a Line, one option, wrapmargin, is essential for editing nonprogram text. wrapmargin specifies the size of the right margin that will be used to autowrap text as you type. (This saves manually typing carriage returns.) A typical value is 7 to 15:

:set wrapmargin=10

Three other options control how vi acts when conducting a search. Normally, a search differentiates between uppercase and lowercase (foo does not match Foo), wraps around to the beginning of the file (meaning that you can begin your search anywhere in the file and still find all occurrences), and recognizes wildcard characters when pattern matching. The default settings that control these options are noignorecase, wrapscan, and magic, respectively. To change any of these defaults, you would set the opposite toggle options: ignorecase, nowrapscan, and nomagic.

Options that may be of particular interest to programmers include autoindent, showmatch, tabstop, shiftwidth, number, and list, as well as their opposite toggle options.

Finally, consider using the autowrite option. When set, vi will automatically write out the contents of a changed buffer when you issue the :n (next) command to move to the next file to be edited, and before running a shell command with :!.





* * *



[29] The location of these two databases varies from vendor to vendor. Try the commands man terminfo and man termcap to get more information about your specific system.



[30] The result of :set all depends very much on the version of vi you have. This particular display is typical of Unix vi; what comes out of the various clones will be different. The order is alphabetical going down the columns, ignoring any leading no.



[31] The original versions of vi automatically read both files, if they existed. The exrc option closes a potential security hole.





Executing Unix Commands





You can display or read in the results of any Unix command while you are editing in vi. An exclamation mark (!) tells ex to create a shell and to regard what follows as a Unix command:

:!command

So if you are editing and you want to check the time or date without exiting vi, you can enter:

:!date

The time and date will appear on your screen; press ENTER to continue editing at the same place in your file.

If you want to give several Unix commands in a row without returning to vi editing in between, you can create a shell with the ex command:

:sh

When you want to exit the shell and return to vi, press CTRL-D.

You can combine :read with a call to Unix, to read the results of a Unix command into your file. As a very simple example:

:r !date

will read in the system’s date information into the text of your file. By preceding the :r command with a line address, you can read the result of the command in at any desired point in your file. By default, it will appear after the current line.

Suppose you are editing a file and want to read in four phone numbers from a file called phone, but in alphabetical order. phone reads:

Willing, Sue 333-4444 Walsh, Linda 555-6666 Quercia, Valerie 777-8888 Dougherty, Nancy 999-0000

The command:

:r !sort phone

reads in the contents of phone after they have been passed through the sort filter:

Dougherty, Nancy 999-0000 Quercia, Valerie 777-8888 Walsh, Linda 555-6666 Willing, Sue 333-4444

Suppose you are editing a file and want to insert text from another file in the directory, but you can’t remember the new file’s name. You could perform this task the long way: exit your file, give the ls command, note the correct filename, reenter your file, and search for your place.

Or you could do the task in fewer steps:

KeystrokesResults

:!ls file1 file2 letter newfile practice

Display a list of files in the current directory. Note the correct filename. Press ENTER to continue editing.



:r newfile "newfile" 35 lines, 949 characters

Read in the new file.





Filtering Text Through a Command





You can also send a block of text as standard input to a Unix command. The output from this command replaces the block of text in the buffer. You can filter text through a command from either ex or vi. The main difference between the two methods is that you indicate the block of text with line addresses in ex and with text objects (movement commands) in vi.





Filtering text with ex





The first example demonstrates how to filter text with ex. Assume that the list of names in the preceding example, instead of being contained in a separate file called phone, is already contained in the current file on lines 96 through 99. You simply type the addresses of the lines you want to filter, followed by an exclamation mark and the Unix command to be executed. For example, the command:

:96,99!sort

will pass lines 96 through 99 through the sort filter and replace those lines with the output of sort.





Filtering text with vi





In vi, text is filtered through a Unix command by typing an exclamation mark followed by any of vi’s movement keystrokes that indicate a block of text, and then by the Unix command line to be executed. For example:

!)command

will pass the next sentence through command.

There are a few unusual aspects of the way vi acts when you use this feature:

The exclamation mark doesn’t appear on your screen right away. When you type the keystroke(s) for the text object you want to filter, the exclamation mark appears at the bottom of the screen, but the character you type to reference the object does not.



Text blocks must be more than one line, so you can use only the keystrokes that would move more than one line ( G, { }, (), [[ ]], +, - ). To repeat the effect, a number may precede either the exclamation mark or the text object. (For example, both !10+ and 10!+ would indicate the next 10 lines.) Objects such as w do not work unless enough of them are specified so as to exceed a single line. You can also use a slash (/) followed by a pattern and a carriage return to specify the object. This takes the text up to the pattern as input to the command.



Entire lines are affected. For example, if your cursor is in the middle of a line and you issue a command to go to the end of the next sentence, the entire lines containing the beginning and end of the sentence will be changed, not just the sentence itself.[32]



There is a special text object that can be used only with this command syntax: you can specify the current line by entering a second exclamation mark:

!!command

Remember that either the entire sequence or the text object can be preceded by a number to repeat the effect. For instance, to change lines 96 through 99 as in the previous example, you could position the cursor on line 96 and enter either:

4!!sort

or:

!4!sort





As another example, assume you have a portion of text in a file that you want to change from lowercase to uppercase letters. You could process that portion with the tr command to change the case. In this example, the second sentence is the block of text that will be filtered through the command:

One sentence before.With a screen editor you can scroll the page move the cursor, delete lines, insert characters, and more, while seeing the results of your edits as you make them. One sentence after.



KeystrokesResults

!) One sentence after. ~ ~ ~ !

An exclamation mark appears on the last line to prompt you for the Unix command. The ) indicates that a sentence is the unit of text to be filtered.



tr '[:lower:]' '[:upper:]' One sentence before.WITH A SCREEN EDITOR YOU CAN SCROLL THE PAGE MOVE THE CURSOR, DELETE LINES, INSERT CHARACTERS, AND MORE, WHILE SEEING THE RESULTS OF YOUR EDITS AS YOU MAKE THEM. One sentence after.

Enter the Unix command and press ENTER. The input is replaced by the output.





To repeat the previous command, the syntax is:

!object !

It is sometimes useful to send sections of a coded document to nroff to be replaced by formatted output. (Or, when editing electronic mail, you might use the fmt program to “beautify” your text before sending the message.) Remember that the “original” input is replaced by the output. Fortunately, if there is a mistake—such as an error message being sent instead of the expected output—you can undo the command and restore the lines.





* * *



[32] Of course, there’s always an exception. In this example, Vim changes only the current line.





Saving Commands





Often you type the same long phrases over and over in a file. vi and ex have a number of different ways of saving long sequences of commands, both in command mode and in insert mode. When you call up one of these saved sequences to execute it, all you do is type a few characters (or even only one), and the entire sequence is executed as if you had entered the whole sequence of commands one by one.





Word Abbreviation





You can define abbreviations that vi will automatically expand into the full text whenever you type the abbreviation in insert mode. To define an abbreviation, use this ex command:

:ababbr phrase

abbr is an abbreviation for the specified phrase. The sequence of characters that make up the abbreviation will be expanded in insert mode only if you type it as a full word; abbr will not be expanded within a word.

Suppose in the file practice you want to enter text that contains a frequently recurring phrase, such as a difficult product or company name. The command:

:ab imrc International Materials Research Center

abbreviates International Materials Research Center to the initials imrc. Now whenever you type imrc in insert mode, imrc expands to the full text.

KeystrokesResults

ithe imrc the International Materials Research Center





Abbreviations expand as soon as you press a nonalphanumeric character (e.g., punctuation), a space, a carriage return, or ESC (returning to command mode). When you are choosing abbreviations, choose combinations of characters that don’t ordinarily occur while you are typing text. If you create an abbreviation that ends up expanding in places where you don’t want it to, you can disable the abbreviation by typing:

:unababbr

To list your currently defined abbreviations, type:

:ab

The characters that compose your abbreviation cannot also appear at the end of your phrase. For example, if you issue the command:

:ab PG This movie is rated PG

you’ll get the message “No tail recursion,” and the abbreviation won’t be set. The message means that you have tried to define something that will expand itself repeatedly, creating an infinite loop. If you issue the command:

:ab PG the PG rating system

you may or may not produce an infinite loop, but in either case you won’t get a warning message. For example, when the above command was tested on a System V version of Unix, the expansion worked. Circa 1990 on a Berkeley version, the abbreviation expanded repeatedly, like this:

the the the the the ...

until a memory error occurred and vi quit.

When tested, we obtained the following results on these vi versions:

Solaris vi

The tail recursive version is not allowed, while the version with the name in the middle of the expansion expands only once.



nvi 1.79

Both versions exceed an internal expansion limit, the expansion stops, and nvi produces an error message.



elvis, Vim, and vile

Both forms are detected and expand only once.





If you are using Unix vi or nvi, we recommend that you avoid repeating your abbreviation as part of the defined phrase.





Using the map Command





While you’re editing, you may find that you are using a command sequence frequently, or that you occasionally use a very complex command sequence. To save yourself keystrokes, or the time that it takes to remember the sequence, you can assign the sequence to an unused key by using the map command.

The map command acts a lot like ab except that you define a macro for vi’s command mode instead of for insert mode:

:map x sequence

Define character x as a sequence of editing commands.



:unmap x

Disable the sequence defined for x.



:map

List the characters that are currently mapped.





Before you can start creating your own maps, you need to know the keys not used in command mode that are available for user-defined commands:

Letters

g, K, q, V, and v



Control keys

^A, ^K, ^O, ^W, and ^X



Symbols

_, *, \, and =





Note


The = is used by vi if Lisp mode is set, and to do text formatting by several of the clones. In many modern versions of vi, the _ is equivalent to the ^ command, and elvis and Vim have a “visual mode” that uses the v, V, and ^V keys. The moral is to test your version carefully.



Depending on your terminal, you may also be able to associate map sequences with special function keys.

With maps, you can create simple or complex command sequences. As a simple example, you could define a command to reverse the order of words. In vi, with the cursor as shown:

you canthe scroll page

the sequence to put the after scroll would be dwelp: delete word, dw; move to the end of next word, e; move one space to the right, l; put the deleted word there, p. Saving this sequence:

:map v dwelp

enables you to reverse the order of two words at any time in the editing session with the single keystroke v.





Protecting Keys from Interpretation by ex





Note that when defining a map, you cannot simply type certain keys, such as ENTER, ESC, BACKSPACE, and DELETE, as part of the command to be mapped, because these keys already have meaning within ex. If you want to include one of these keys as part of the command sequence, you must escape the normal meaning by preceding the key with CTRL-V. The keystroke ^V appears in the map as the ^ character. Characters following the ^V also do not appear as you expect. For example, a carriage return appears as ^M, escape as ^[, backspace as ^H, and so on.

On the other hand, if you want to use a control character as the character to be mapped, in most cases all you have to do is hold down the CTRL key and press the letter key at the same time. So, for example, all you need to do in order to map ^A is to type:

:mapCTRL-Asequence

There are, however, three control characters that must be escaped with a ^V. They are ^T, ^W, and ^X. So, for example, if you want to map ^T, you must type:

:mapCTRL-VCTRL-Tsequence

The use of CTRL-V applies to any ex command, not just a map command. This means that you can type a carriage return in an abbreviation or a substitution command. For example, the abbreviation:

:ab 123 one^Mtwo^Mthree

expands to this:

one two three

(Here we show the sequence CTRL-V ENTER as ^M, the way it would appear on your screen.)

You can also globally add lines at certain locations. The command:

:g/^Section/s//As you recall, in^M&/

inserts, before all lines beginning with the word Section, a phrase on a separate line. The & restores the search pattern.

Unfortunately, one character always has special meaning in ex commands, even if you try to quote it with CTRL-V. Recall that the vertical bar (|) has special meaning as a separator of multiple ex commands. You cannot use a vertical bar in insert mode maps.

Now that you’ve seen how to use CTRL-V to protect certain keys inside ex commands, you’re ready to define some powerful map sequences.





A Complex Mapping Example





Assume that you have a glossary with entries like this:

map - an ex command which allows you to associate a complex command sequence with a single key.

You would like to convert this glossary list to troff format, so that it looks like this:

.IP "map" 10n An ex command...

The best way to define a complex map is to do the edit once manually, writing down each keystroke that you have to type. Then recreate these keystrokes as a map. You want to:

Insert the MS macro for an indented paragraph at the beginning of the line. Insert the first quotation mark as well (I.IP ").



Press ESC to terminate insert mode.



Move to the end of the first word (e) and add a second quotation mark, followed by a space and the size of the indent (a" 10n).



Press ENTER to insert a new line.



Press ESC to terminate insert mode.



Remove the hyphen and two surrounding spaces (3x) and capitalize the next word (~).





That will be quite an editing chore if you have to repeat it more than just a few times.

With :map you can save the entire sequence so that it can be reexecuted with a single keystroke:

:map g I.IP "^[ea" 10n^M^[3x~

Note that you have to “quote” both the ESC and the ENTER characters with CTRL-V. ^[ is the sequence that appears when you type CTRL-V followed by ESC. ^M is the sequence shown when you type CTRL-V ENTER.

Now, simply typing g will perform the entire series of edits. On a slow connection you can actually see the edits happening individually. On a fast one it will seem to happen by magic.

Don’t be discouraged if your first attempt at key mapping fails. A small error in defining the map can give very different results from the ones you expect. Type u to undo the edit, and try again.





More Examples of Mapping Keys





The following examples will give you an idea of the clever shortcuts possible when defining keyboard maps:

Add text whenever you move to the end of a word:

:map e ea

Most of the time, the only reason you want to move to the end of a word is to add text. This map sequence puts you in insert mode automatically. Note that the mapped key, e, has meaning in vi. You’re allowed to map a key that is already used by vi, but the key’s normal function will be unavailable as long as the map is in effect. This isn’t so bad in this case, since the E command is often identical to e.



Transpose two words:

:map K dwElp

We discussed this sequence earlier in the chapter, but now you need to use E (assume here, and in the remaining examples, that the e command is mapped to ea). Remember that the cursor begins on the first of the two words. Unfortunately, because of the l command, this sequence (and the earlier version) doesn’t work if the two words are at the end of a line: during the sequence, the cursor ends up at the end of the line, and l cannot move further right. Here’s a better solution:

:map K dwwP

You could also use W instead of w.



Save a file and edit the next one in a series:

:map q :w^M:n^M

Notice that you can map keys to ex commands, but be sure to finish each ex command with a carriage return. This sequence makes it easy to move from one file to the next and is useful when you’ve opened many short files with one vi command. Mapping the letter q helps you remember that the sequence is similar to a “quit.”



Put troff emboldening codes around a word:

:map v i\fB^[e\fP^[

This sequence assumes that the cursor is at the beginning of the word. First, you enter insert mode, then you type the code for the bold font. In map commands, you don’t need to type two backslashes to produce one backslash. Next, you return to command mode by typing a “quoted” ESC. Finally, you append the closing troff code at the end of the word, and you return to command mode. Notice that when we appended to the end of the word, we didn’t need to use ea, since this sequence is itself mapped to the single letter e. This shows you that map sequences are allowed to contain other mapped commands. (The ability to use nested map sequences is controlled by vi’s remap option, which is normally enabled.)



Put HTML emboldening codes around a word, even when the cursor is not at the beginning of the word:

:map V lbi<B>^[e</B>^[

This sequence is similar the previous one; besides using HTML instead of troff, it uses lb to handle the additional task of positioning the cursor at the beginning of the word. The cursor might be in the middle of the word, so you want to move to the beginning with the b command. But if the cursor were already at the beginning of the word, the b command would move the cursor to the previous word instead. To guard against that case, type an l before moving back with b, so that the cursor never starts on the first letter of the word. You can define variations of this sequence by replacing the b with B and the e with Ea. In all cases, though, the l command prevents this sequence from working if the cursor is at the end of a line. (You could append a space to get around this.)



Repeatedly find and remove parentheses from around a word or phrase: [33]

:map = xf)xn

This sequence assumes that you first found an open parenthesis, by typing /( followed by ENTER.

If you choose to remove the parentheses, use the map command: delete the open parenthesis with x, find the closing one with f), delete it with x, and then repeat your search for an open parenthesis with n.

If you don’t want to remove the parentheses (for example, if they’re being used correctly), don’t use the mapped command: press n instead to find the next open parenthesis.

You could also modify the map sequence in this example to handle matching pairs of quotes.



Place C/C++ comments around an entire line:

:map g I/* ^[A */^[

This sequence inserts /* at the line’s beginning and appends */ at the line’s end. You could also map a substitute command to do the same thing:

:map g :s;.*;/* & */;^M

Here, you match the entire line (with .*), and when you replay it (with &), you surround the line with the comment symbols. Note the use of semicolon delimiters, to avoid having to escape the / in the comment.



Safely repeat a long insertion:

:map ^J :set wm=0^M.:set wm=10^M

We mentioned in Chapter 2 that vi occasionally has difficulty repeating long insertions of text when wrapmargin is set. This map command is a useful workaround. It temporarily turns off the wrapmargin (by setting it to 0), gives the repeat command, and then restores the wrapmargin. Note that a map sequence can combine ex and vi commands.





In the previous example, even though ^J is a vi command (it moves the cursor down a line), this key is safe to map because it’s really the same as the j command. There are many keys that either perform the same tasks as other keys or are rarely used. However, you should be familiar with the vi commands before you boldly disable their normal use by using them in map definitions.





Mapping Keys for Insert Mode





Normally, maps apply only to command mode—after all, in insert mode, keys stand for themselves and shouldn’t be mapped as commands. However, by adding an exclamation mark (!) to the map command, you can force it to override the ordinary meaning of a key and produce the map in insert mode. This feature is useful when you find yourself in insert mode but need to escape briefly to command mode, run a command, and then return to insert mode.

For example, suppose you just typed a word but forgot to italicize it (or place quotes around it, etc.). You can define this map:

:map! + ^[bi<I>^[ea</I>

Now, when you type a + at the end of a word, you will surround the word with HTML italicization codes. The + won’t show up in the text.

The sequence just shown escapes to command mode (^[), backs up to insert the first code (bi<I>), escapes again (^[), and moves ahead to append the second code (ea</I>). Since the map sequence begins and ends in insert mode, you can continue entering text after marking the word.

Here’s another example. Suppose that you’ve been typing your text, and you realize that the previous line should have ended with a colon. You can correct that by defining this map sequence:[34]

:map! % ^[kA:^[jA

Now, if you type a % anywhere along your current line, you’ll append a colon to the end of the previous line. This command escapes to command mode, moves up a line, and appends the colon (^[kA:). The command then escapes again, moves down to the line you were on, and leaves you in insert mode (^[jA).

Note that we wanted to use uncommon characters (% and +) for the previous map commands. When a character is mapped for insert mode, you can no longer type that character as text.

To reinstate a character for normal typing, use the command:

:unmap!x

where x is the character that was previously mapped for insert mode. (Although vi will expand x on the command line as you type it, making it look like you are unmapping the expanded text, it will correctly unmap the character.)

Insert-mode mapping is often more appropriate for tying character strings to special keys that you wouldn’t otherwise use. It is especially useful with programmable function keys.





Mapping Function Keys





Many terminals have programmable function keys (which are faithfully emulated by today’s terminal emulators on bitmapped workstations). You can usually set up these keys to print whatever character or characters you want using a special setup mode on the terminal. However, keys programmed using a terminal’s setup mode work only on that terminal; they may also limit the action of programs that want to set up those function keys themselves.

ex allows you to map function keys by number, using the syntax:

:map #1commands

for function key number 1, and so on. (It can do this because the editor has access to the entry for that terminal found in either the terminfo or termcap database and knows the escape sequence normally put out by the function key.)

As with other keys, maps apply by default to command mode, but by using the map! commands as well, you can define two separate values for a function key—one to be used in command mode, the other in insert mode. For example, if you are an HTML user, you might want to put font-switch codes on function keys. For example:

:map #1 i<I>^[ :map! #1 <I>

If you are in command mode, the first function key will enter insert mode, type in the three characters <I>, and return to command mode. If you are already in insert mode, the key will simply type the three-character HTML code.

If the sequence contains ^M, which is a carriage return, press CTRL-M. For instance, in order to have function key 1 available for mapping, the terminal database entry for your terminal must have a definition of k1, such as:

k1=^A@^M

In turn, the definition:

^A@^M

must be what is output when you press that key.

To see what the function key puts out, use the od (octal dump) command with the -c option (show each character). You will need to press ENTER after the function key, and then CTRL-D to get od to print the information. For example:

$od -c ^[[[A ^D 0000000 033 [ [ A \n 0000005

Here, the function key sent Escape, two left brackets, and an A.





Mapping Other Special Keys





Many keyboards have special keys, such as HOME, END, PAGE UP, and PAGE DOWN, that duplicate commands in vi. If the terminal’s terminfo or termcap description is complete, vi will be able to recognize these keys. But if it isn’t, you can use the map command to make them available to vi. These keys generally send an escape sequence to the computer—an Escape character followed by a string of one or more other characters. To trap the Escape, you should press ^V before pressing the special key in the map. For example, to map the HOME key on the keyboard of an IBM PC to a reasonable vi equivalent, you might define the following map:

:map CTRL-V HOME 1G

This appears on your screen as:

:map ^[[H 1G

Similar map commands display as follows:

:mapCTRL-V END G displays :map ^[[Y G :map CTRL-V PAGE UP ^F displays :map ^[[V ^F :map CTRL-V PAGE DOWN ^B displays :map ^[[U ^B

You’ll probably want to place these maps in your .exrc file. Note that if a special key generates a long escape sequence (containing multiple nonprinting characters), ^V quotes only the initial escape character, and the map doesn’t work. You will have to find the entire escape sequence (perhaps from the terminal manual) and type it in manually, quoting at the appropriate points, rather than simply pressing ^V and then the key.

If you use different kinds of terminals (such as both the console of a PC and an xterm), you cannot expect that mappings like those just presented will always work. For this reason, Vim provides a portable way to describe such key mappings:

:map <Home> 1GEnter six characters: < H o m e > (Vim)





Mapping Multiple Input Keys





Mapping multiple keystrokes is not restricted just to function keys. You can also map sequences of regular keystrokes. This can help make it easier to enter certain kinds of text, such as XML or HTML.

Here are some :map commands, thanks to Jerry Peek, coauthor of O’Reilly’s Learning the Unix Operating System, that make it easier to enter XML markup. (The lines beginning with a double quote are comments. This is discussed later in the section Comments in ex Scripts.)

" ADR: need this :set noremap " bold: map! =b </emphasis>^[F<i<emphasis role="bold"> map =B i<emphasis role="bold">^[ map =b a</emphasis>^[ " Move to end of next tag: map! =e ^[f>a map =e f> " footnote (tacks opening tag directly after cursor in text-input mode): map! =f <footnote>^M<para>^M</para>^M</footnote>^[kO " Italics ("emphasis"): map! =i </emphasis>^[F<i<emphasis> map =I i<emphasis>^[ map =i a</emphasis>^[ " paragraphs: map! =p ^[jo<para>^M</para>^[O map =P O<para>^[ map =p o</para>^[ " less-than: map! *l &lt; ...

Using these commands, to enter a footnote you would enter insert mode and type =f. vi would then insert the opening and closing tags, and leave you in insert mode between them:

All the world's a stage.<footnote> <para> </para> </footnote>

Needless to say, these macros proved quite useful during the development of this book.





@-Functions





Named buffers provide yet another way to create “macros”—complex command sequences that you can repeat with only a few keystrokes.

If you type a command line in your text (either a vi sequence or an ex command preceded by a colon), and then delete it into a named buffer, you can execute the contents of that buffer with the @ command. For example, open a new line and enter:

cwgadflyCTRL-VESC



This will appear as:

cwgadfly^[

on your screen. Press ESC again to exit insert mode, then delete the line into buffer g by typing "gdd. Now whenever you place the cursor at the beginning of a word and type @g, that word in your text will be changed to gadfly.

Since @ is interpreted as a vi command, a dot (.) will repeat the entire sequence, even if the buffer contains an ex command. @@ repeats the last @, and u or U can be used to undo the effect of @.

This is a simple example. @-functions are useful because they can be adapted to very specific commands. They are especially useful when you are editing between files, because you can store the commands in their named buffers and access them from any file you edit. @-functions are also useful in combination with the global replacement commands discussed in Chapter 6.





Executing Buffers from ex





You can also execute text saved in a buffer from ex mode. In this case, you would enter an ex command, delete it into a named buffer, and then use the @ command from the ex colon prompt. For example, enter the following text:

ORA publishes great books. ORA is my favorite publisher. 1,$s/ORA/O'Reilly Media/g

With your cursor on the last line, delete the command into the g buffer: "gdd. Move your cursor to the first line: kk. Then, execute the buffer from the colon command line: :@g ENTER. Your screen should now look like this:

O'Reilly Media publishes great books. O'Reilly Media is my favorite publisher.

Some versions of vi treat * identically to @ when used from the ex command line. In addition, if the buffer character supplied after the @ or * command is *, the command will be taken from the default (unnamed) buffer.





* * *



[33] From the article by Walter Zintz, in Unix World, April 1990.



[34] From an article by Walter Zintz, in Unix World, April 1990.





Using ex Scripts





Certain ex commands you use only within vi, such as maps, abbreviations, and so on. If you store these commands in your .exrc file, the commands will automatically be executed when you invoke vi. Any file that contains commands to execute is called a script.

The commands in a typical .exrc script are of no use outside vi. However, you can save other ex commands in a script, and then execute the script on a file or on multiple files. Mostly you’ll use substitute commands in these external scripts.

For a writer, a useful application of ex scripts is to ensure consistency of terminology—or even of spelling—across a document set. For example, let’s assume that you’ve run the Unix spell command on two files and that the command has printed out the following list of misspellings:

$spell sect1 sect2 chmod ditroff myfile thier writeable

As is often the case, spell has flagged a few technical terms and special cases it doesn’t recognize, but it has also identified two genuine spelling errors.

Because we checked two files at once, we don’t know which files the errors occurred in or where they are in the files. Although there are ways to find this out, and the job wouldn’t be too hard for only two errors in two files, you can easily imagine how time-consuming the job could grow to be for a poor speller or for a typist proofing many files at once.

To make the job easier, you could write an ex script containing the following commands:

%s/thier/their/g %s/writeable/writable/g wq

Assume you’ve saved these lines in a file named exscript. The script could be executed from within vi with the command:

:so exscript

or the script can be applied to a file right from the command line. Then you could edit the files sect1 and sect2 as follows:

$ex -s sect1 < exscript $ex -s sect2 < exscript

The -s following the invocation of ex is the POSIX way to tell the editor to suppress the normal terminal messages.[35]

If the script were longer than the one in our simple example, we would already have saved a fair amount of time. However, you might wonder if there isn’t some way to avoid repeating the process for each file to be edited. Sure enough, we can write a shell script that includes—but generalizes—the invocation of ex, so that it can be used on any number of files.





Looping in a Shell Script





You may know that the shell is a programming language as well as a command-line interpreter. To invoke ex on a number of files, we use a simple type of shell script command called the for loop. A for loop allows you to apply a sequence of commands for each argument given to the script. (The for loop is probably the single most useful piece of shell programming for beginners. You’ll want to remember it even if you don’t write any other shell programs.)

Here’s the syntax of a for loop:

forvariable in list do command(s) done

For example:

for file in $* do ex - $file < exscript done

(The command doesn’t need to be indented; we indented it for clarity.) After we create this shell script, we save it in a file called correct and make it executable with the chmod command. (If you aren’t familiar with the chmod command and the procedures for adding a command to your Unix search path, see Learning the Unix Operating System, published by O’Reilly.) Now type:

$correct sect1 sect2

The for loop in correct will assign each argument (each file in the list specified by $*, which stands for all arguments) to the variable file and execute the ex script on the contents of that variable.

It may be easier to grasp how the for loop works with an example whose output is more visible. Let’s look at a script to rename files:

for file in $* do mv $file $file.x done

Assuming this script is in an executable file called move, here’s what we can do:

$ls ch01 ch02 ch03 move $ move ch?? Just the chapter files $ ls Check the results ch01.x ch02.x ch03.x move

With creativity, you could rewrite the script to rename the files more specifically:

for nn in $* do mv ch$nn sect$nn done

With the script written this way, you’d specify numbers instead of filenames on the command line:

$ls ch01 ch02 ch03 move $ move 01 02 03 $ ls sect01 sect02 sect03 move

The for loop need not take $* (all arguments) as the list of values to be substituted. You can specify an explicit list as well. For example:

forvariable ina b c d

assigns variable to a, b, c, and d in turn. Or you can substitute the output of a command. For example:

forvariable in `grep -l "Alcuin" *`

assigns variable in turn to the name of each file in which grep finds the string Alcuin. (grep -l prints the filenames whose contents match the pattern, without printing the actual matching lines.)

If no list is specified:

forvariable

the variable is assigned to each command-line argument in turn, much as it was in our initial example. This is actually not equivalent to:

forvariable in $*

but to:

forvariable in "$@"

which has a slightly different meaning. The symbol $* expands to $1, $2, $3, etc., but the four-character sequence "$@" expands to "$1", "$2", "$3", etc. Quotation marks prevent further interpretation of special characters.

Let’s return to our main point and our original script:

for file in $* do ex - $file < exscript done

It may seem a little inelegant to have to use two scripts—the shell script and the ex script. And in fact, the shell does provide a way to include an editing script inside a shell script.





Here Documents





In a shell script, the operator << means to take the following lines, up to a specified string, as input to a command. (This is often called a here document.) Using this syntax, we could include our editing commands in correct like this:

for file in $* do ex - $file << end-of-script g/thier/s//their/g g/writeable/s//writable/g wq end-of-script done

The string end-of-script is entirely arbitrary—it just needs to be a string that won’t otherwise appear in the input and can be used by the shell to recognize when the here document is finished. It also must be placed at the start of the line. By convention, many users specify the end of a here document with the string EOF, or E_O_F, to indicate the end of the file.

There are advantages and disadvantages to each approach shown. If you want to make a one-time series of edits and don’t mind rewriting the script each time, the here document provides an effective way to do the job.

However, it’s more flexible to write the editing commands in a separate file from the shell script. For example, you could establish the convention that you will always put editing commands in a file called exscript. Then you only need to write the correct script once. You can store it away in your personal “tools” directory (which you’ve added to your search path) and use it whenever you like.





Sorting Text Blocks: A Sample ex Script





Suppose you want to alphabetize a file of troff-encoded glossary definitions. Each term begins with an .IP macro. In addition, each entry is surrounded by the .KS/.KE macro pair. (This ensures that the term and its definition will print as a block and will not be split across a new page.) The glossary file looks something like this:

.KS .IP "TTY_ARGV" 2n The command, specified as an argument vector, that the TTY subwindow executes. .KE .KS .IP "ICON_IMAGE" 2n Sets or gets the remote image for icon's image. .KE .KS .IP "XV_LABEL" 2n Specifies a frame's header or an icon's label. .KE .KS .IP "SERVER_SYNC" 2n Synchronizes with the server once. Does not set synchronous mode. .KE

You can alphabetize a file by running the lines through the Unix sort command, but you don’t really want to sort every line. You want to sort only the glossary terms, moving each definition—untouched—along with its corresponding term. As it turns out, you can treat each text block as a unit by joining the block into one line. Here’s the first version of your ex script:

g/^\.KS/,/^\.KE/j %!sort

Each glossary entry is found between a .KS and .KE macro. j is the ex command to join a line (the equivalent in vi is J). So, the first command joins every glossary entry into one “line.” The second command then sorts the file, producing lines like this:

.KS .IP "ICON_IMAGE" 2n Sets or gets ... image. .KE .KS .IP "SERVER_SYNC" 2n Synchronizes with ... mode. .KE .KS .IP "TTY_ARGV" 2n The command, ... executes. .KE .KS .IP "XV_LABEL" 2n Specifies a ... icon's label. .KE

The lines are now sorted by glossary entry; unfortunately, each line also has macros and text mixed in (we’ve used ellipses [...] to show omitted text). Somehow, you need to insert newlines to “un-join” the lines. You can do this by modifying your ex script: mark the joining points of the text blocks before you join them, and then replace the markers with newlines. Here’s the expanded ex script:

g/^\.KS/,/^\.KE/-1s/$/@@/ g/^\.KS/,/^\.KE/j %!sort %s/@@ /^M/g

The first three commands produce lines like this:



.KS@@ .IP "ICON_IMAGE" 2nn@@ Sets or gets ... image. @@ .KE .KS@@ .IP "SERVER_SYNC" 2nn@@ Synchronizes with ... mode. @@ .KE .KS@@ .IP "TTY_ARGV" 2nn@@ The ... vector, @@ that ... .@@ .KE .KS@@ .IP "XV_LABEL" 2nn@@ Specifies a ... icon's label. @@ .KE

Note the extra space following the @@. The spaces result from the j command, because it converts each newline into a space.

The first command marks the original line breaks with @@. You don’t need to mark the end of the block (after the .KE), so the first command uses a -1 to move back up one line at the end of each block. The fourth command restores the line breaks by replacing the markers (plus the extra space) with newlines. Now your file is sorted by blocks.





Comments in ex Scripts





You may want to reuse such a script, adapting it to a new situation. With a complex script like this, it is wise to add comments so that it’s easier for someone else (or even yourself!) to reconstruct how it works. In ex scripts, anything following a double quote is ignored during execution, so a double quote can mark the beginning of a comment. Comments can go on their own line. They can also go at the end of any command that doesn’t interpret a quote as part of the command. (For example, a quote has meaning to map commands and shell escapes, so you can’t end such lines with a comment.)

Besides using comments, you can specify a command by its full name, something that would ordinarily be too time-consuming from within vi. Finally, if you add spaces, the ex script shown previously becomes this more readable one:

" Mark lines between each KS/KE block global /^\.KS/,/^\.KE/-1 s /$/@@/ " Now join the blocks into one line global /^\.KS/,/^\.KE/ join " Sort each block--now really one line each %!sort " Restore the joined lines to original blocks % s /@@ /^M/g

Surprisingly, the substitute command does not work in ex, even though the full names for the other commands do.





Beyond ex





If this discussion has whetted your appetite for even more editing power, you should be aware that Unix provides editors even more powerful than ex: the sed stream editor and the awk data manipulation language. There is also the extremely popular perl programming language. For information on these programs, see the O’Reilly books sed & awk, Effective awk Programming, Learning Perl, and Programming Perl.





* * *



[35] Traditionally, ex used a single minus sign for this purpose. Typically, for backward compatibility, both versions are accepted.





Editing Program Source Code





All of the features discussed so far are of interest whether you are editing regular text or program source code. However, there are a number of additional features that are of interest chiefly to programmers. These include indentation control, searching for the beginning and end of procedures, and using ctags.

The following discussion is adapted from documentation provided by Mortice Kern Systems with their excellent implementation of vi for DOS and Windows-based systems, available as a part of the MKS Toolkit or separately as MKS Vi. It is reprinted by permission of Mortice Kern Systems.





Indentation Control





The source code for a program differs from ordinary text in a number of ways. One of the most important of these is the way in which source code uses indentation. Indentation shows the logical structure of the program: the way in which statements are grouped into blocks. vi provides automatic indentation control. To use it, issue the command:

:set autoindent

Now, when you indent a line with spaces or tabs, the following lines will automatically be indented by the same amount. When you press ENTER after typing the first indented line, the cursor goes to the next line and automatically indents the same distance as the previous line.

As a programmer, you will find this saves you quite a bit of work getting the indentation right, especially when you have several levels of indentation.

When you are entering code with autoindent enabled, typing CTRL-T at the start of a line gives you another level of indentation, and typing CTRL-D takes one away.

We should point out that CTRL-T and CTRL-D are typed while you are in insert mode, unlike most other commands, which are typed in command mode.

There are two additional variants of the CTRL-D command:[36]

^ ^D

When you type ^ ^D (^ CTRL-D), vi shifts the cursor back to the beginning of the line, but only for the current line. The next line you enter will start at the current autoindent level. This is particularly useful for entering C preprocessor commands while typing in C/C++ source code.



0 ^D

When you type 0 ^D, vi shifts the cursor back to the beginning of the line. In addition, the current autoindent level is reset to zero; the next line you enter will not be autoindented.[37]





Try using the autoindent option when you are entering source code. It simplifies the job of getting indentation correct. It can even sometimes help you avoid bugs—e.g., in C source code, where you usually need one closing curly brace (}) for every level of indentation you go backward.

The << and >> commands are also helpful when indenting source code. By default, >> shifts a line right eight spaces (i.e., adds eight spaces of indentation) and << shifts a line left eight spaces. For example, move the cursor to the beginning of a line and press > twice (>>). You will see the line move right. If you now press < twice (<<), the line will move back again.

You can shift a number of lines by typing the number followed by >> or <<. For example, move the cursor to the first line of a good-sized paragraph and type 5>>. You will shift the first five lines in the paragraph.

The default shift is eight spaces (right or left). This default can be changed with a command such as:

:set shiftwidth=4

You will find it convenient to have a shiftwidth that is the same size as the width between tab stops.

vi attempts to be smart when doing indenting. Usually, when you see text indented by eight spaces at a time, vi will actually insert tab characters into the file, since tabs usually expand to eight spaces. This is the Unix default; it is most noticeable when you type a tab during normal input and when files are sent to a printer—Unix expands them with a tab stop of eight spaces.

If you wish, you can change how vi represents tabs on your screen, by changing the tabstop option. For example, if you have something that is deeply indented, you might wish to have use a tab stop setting of every four characters, so that the lines will not wrap. The following command will make this change:

:set tabstop=4





Note


Changing your tab stops is not recommended. Although vi will display the file using an arbitrary tab stop setting, the tab characters in your files will still be expanded using an eight-character tab stop by every other Unix program.

Even worse: mixing tabs, spaces, and unusal tab stops will make your file completely unreadable when viewed outside the editor, with a pager such as more, or when printed. Eight-character tab stops are one of the facts of life on Unix, and you should just get used to them.



Sometimes indentation won’t work the way you expect, because what you believe to be a tab character is actually one or more spaces. Normally, your screen displays both a tab and a space as whitespace, making the two indistinguishable. You can, however, issue the command:

:set list

This alters your display so that a tab appears as the control character ^I and an end-of-line appears as a $. This way, you can spot a true space, and you can see extra spaces at the end of a line. A temporary equivalent is the :l command. For example, the command:

:5,20 l

displays lines 5 through 20, showing tab characters and end-of-line characters.





A Special Search Command





The characters (, [, {, and < can all be called opening brackets. When the cursor is resting on one of these characters, pressing the % key moves the cursor from the opening bracket forward to the corresponding closing bracket—), ], }, or >—keeping in mind the usual rules for nesting brackets.[38] For example, if you were to move the cursor to the first ( in:

if ( cos(a[i]) == sin(b[i]+c[i]) ) { printf("cos and sin equal!\n"); }

and press %, you would see that the cursor jumps to the parenthesis at the end of the line. This is the closing parenthesis that matches the opening one.

Similarly, if the cursor is on one of the closing bracket characters, pressing % will move the cursor backward to the corresponding opening bracket character. For example, move the cursor to the closing brace after the printf line just shown and press %.

vi is even smart enough to find a bracket character for you. If the cursor is not on a bracket character, when you press %, vi will search forward on the current line to the first open or close bracket character it finds, and then it will move to the matching bracket! For instance, with the cursor on the > in the first line of the example just shown, % will find the open parenthesis and then move to the close parenthesis.

Not only does this search character help you move forward and backward through a program in long jumps, it lets you check the nesting of brackets and parentheses in source code. For example, if you put the cursor on the first { at the beginning of a C function, pressing % should move you to the } that (you think) ends the function. If it’s the wrong one, something has gone wrong somewhere. If there is no matching } in the file, vi will beep at you.

Another technique for finding matching brackets is to turn on the following option:

:set showmatch

Unlike %, setting showmatch (or its abbreviation sm) helps you while you’re in insert mode. When you type a ) or a },[39] the cursor will briefly move back to the matching ( or { before returning to your current position. If the match doesn’t exist, the terminal beeps. If the match is merely off-screen, vi silently keeps going. Vim 7.0 and later can highlight the matching parenthesis or brace, using the matchparen plugin, which is loaded by default.





Using Tags





The source code for a large C or C++ program will usually be spread over several files. Sometimes, it is difficult to keep track of which file contains which function definitions. To simplify matters, a Unix command called ctags can be used together with the :tag command of vi.





Note


Unix versions of ctags handle the C language and often Pascal and Fortran 77. Sometimes they even handle assembly language. Almost universally, however, they do not handle C++. Other versions are available that can generate tags files for C++ and for other languages and file types. For more information, see Enhanced Tags.



You issue the ctags command at the Unix command line. Its purpose is to create an information file that vi can use later to determine which files define which functions. By default, this file is called tags. From within vi, a command of the form:

:!ctags file.c

creates a file named tags in your current directory that contains information on the functions defined in file.c. A command such as:

:!ctags *.c

creates a tags file describing all the C source files in the directory.

Now suppose your tags file contains information on all the source files that make up a C program. Also suppose that you want to look at or edit a function in the program, but you do not know where the function is. From within vi, the command:

:tagname

looks at the tags file to find out which file contains the definition of the function name. It then reads in the file and positions the cursor on the line where the name is defined. In this way, you don’t have to know which file you have to edit; you only have to decide which function you want to edit.

You can use the tag facility from vi’s command mode as well. Place the cursor on the identifier you wish to look up, and then type ^]. vi will perform the tag lookup and move to the file that defines the identifier. Be careful where you place the cursor; vi uses the “word” under the cursor starting at the current cursor position, not the entire word containing the cursor.





Note


If you try to use the :tag command to read in a new file and you haven’t saved your current text since the last time you changed it, vi will not let you go to the new file. You must either write out your current file with the :w command and then issue :tag, or else type:

:tag!name

to override vi’s reluctance to discard edits.



The Solaris version of vi actually supports tag stacks. It appears, however, to be completely undocumented in the Solaris manpages. Because many, if not most, versions of Unix vi don’t do tag stacking, in this book we have moved the discussion of this feature to Tag Stacks where tag stacking is introduced.





* * *



[36] These do not work in elvis.



[37] The nvi 1.79 documentation has these two commands switched, but the program actually behaves as described here.



[38] Of the versions tested, only nvi supported matching < and > with %. vile lets you set an option with the sets of pairs of characters that match for %.



[39] In elvis, Vim, and vile, showmatch also shows you matching square brackets ([ and ]).





