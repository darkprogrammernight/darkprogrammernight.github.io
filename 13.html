13. Low-Level Programming


The design of Go guarantees a number of safety properties that limit the ways in which a Go program can “go wrong.” During compilation, type checking detects most attempts to apply an operation to a value that is inappropriate for its type, for instance, subtracting one string from another. Strict rules for type conversions prevent direct access to the internals of built-in types like strings, maps, slices, and channels.

For errors that cannot be detected statically, such as out-of-bounds array accesses or nil pointer dereferences, dynamic checks ensure that the program immediately terminates with an informative error whenever a forbidden operation occurs. Automatic memory management (garbage collection) eliminates “use after free” bugs, as well as most memory leaks.

Many implementation details are inaccessible to Go programs. There is no way to discover the memory layout of an aggregate type like a struct, or the machine code for a function, or the identity of the operating system thread on which the current goroutine is running. Indeed, the Go scheduler freely moves goroutines from one thread to another. A pointer identifies a variable without revealing the variable’s numeric address. Addresses may change as the garbage collector moves variables; pointers are transparently updated.

Together, these features make Go programs, especially failing ones, more predictable and less mysterious than programs in C, the quintessential low-level language. By hiding the underlying details, they also make Go programs highly portable, since the language semantics are largely independent of any particular compiler, operating system, or CPU architecture. (Not entirely independent: some details leak through, such as the word size of the processor, the order of evaluation of certain expressions, and the set of implementation restrictions imposed by the compiler.)

Occasionally, we may choose to forfeit some of these helpful guarantees to achieve the highest possible performance, to interoperate with libraries written in other languages, or to implement a function that cannot be expressed in pure Go.

In this chapter, we’ll see how the unsafe package lets us step outside the usual rules, and how to use the cgo tool to create Go bindings for C libraries and operating system calls.

The approaches described in this chapter should not be used frivolously. Without careful attention to detail, they may cause the kinds of unpredictable, inscrutable, non-local failures with which C programmers are unhappily acquainted. Use of unsafe also voids Go’s warranty of compatibility with future releases, since, whether intended or inadvertent, it is easy to depend on unspecified implementation details that may change unexpectedly.

The unsafe package is rather magical. Although it appears to be a regular package and is imported in the usual way, it is actually implemented by the compiler. It provides access to a number of built-in language features that are not ordinarily available because they expose details of Go’s memory layout. Presenting these features as a separate package makes the rare occasions on which they are needed more conspicuous. Also, some environments may restrict the use of the unsafe package for security reasons.

Package unsafe is used extensively within low-level packages like runtime, os, syscall, and net that interact with the operating system, but is almost never needed by ordinary programs.





13.1 unsafe.Sizeof, Alignof, and Offsetof


The unsafe.Sizeof function reports the size in bytes of the representation of its operand, which may be an expression of any type; the expression is not evaluated. A call to Sizeof is a constant expression of type uintptr, so the result may be used as the dimension of an array type, or to compute other constants.

Click here to view code image

import "unsafe" fmt.Println(unsafe.Sizeof(float64(0))) // "8"

Sizeof reports only the size of the fixed part of each data structure, like the pointer and length of a string, but not indirect parts like the contents of the string. Typical sizes for all non-aggregate Go types are shown below, though the exact sizes may vary by toolchain. For portability, we’ve given the sizes of reference types (or types containing references) in terms of words, where a word is 4 bytes on a 32-bit platform and 8 bytes on a 64-bit platform.

Computers load and store values from memory most efficiently when those values are properly aligned. For example, the address of a value of a two-byte type such as int16 should be an even number, the address of a four-byte value such as a rune should be a multiple of four, and the address of an eight-byte value such as a float64, uint64, or 64-bit pointer should be a multiple of eight. Alignment requirements of higher multiples are unusual, even for larger data types such as complex128.

For this reason, the size of a value of an aggregate type (a struct or array) is at least the sum of the sizes of its fields or elements but may be greater due to the presence of “holes.” Holes are unused spaces added by the compiler to ensure that the following field or element is properly aligned relative to the start of the struct or array.





Type Size

bool 1 byte

intN, uintN, floatN, complexN N / 8 bytes (for example, float64 is 8 bytes)

int, uint, uintptr 1 word

*T 1 word

string 2 words (data, len)

[]T 3 words (data, len, cap)

map 1 word

func 1 word

chan 1 word

interface 2 words (type, value)

The language specification does not guarantee that the order in which fields are declared is the order in which they are laid out in memory, so in theory a compiler is free to rearrange them, although as we write this, none do. If the types of a struct’s fields are of different sizes, it may be more space-efficient to declare the fields in an order that packs them as tightly as possible. The three structs below have the same fields, but the first requires up to 50% more memory than the other two:

Click here to view code image

// 64-bit 32-bit struct{ bool; float64; int16 } // 3 words 4 words struct{ float64; int16; bool } // 2 words 3 words struct{ bool; int16; float64 } // 2 words 3 words

The details of the alignment algorithm are beyond the scope of this book, and it’s certainly not worth worrying about every struct, but efficient packing may make frequently allocated data structures more compact and therefore faster.

The unsafe.Alignof function reports the required alignment of its argument’s type. Like Sizeof, it may be applied to an expression of any type, and it yields a constant. Typically, boolean and numeric types are aligned to their size (up to a maximum of 8 bytes) and all other types are word-aligned.

The unsafe.Offsetof function, whose operand must be a field selector x.f, computes the offset of field f relative to the start of its enclosing struct x, accounting for holes, if any.

Figure 13.1 shows a struct variable x and its memory layout on typical 32- and 64-bit Go implementations. The gray regions are holes.

var x struct { a bool b int16 c []int }

Figure 13.1. Holes in a struct.



The table below shows the results of applying the three unsafe functions to x itself and to each of its three fields:

Click here to view code image

Typical 32-bit platform: Sizeof(x) = 16 Alignof(x) = 4 Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 Sizeof(x.c) = 12 Alignof(x.c) = 4 Offsetof(x.c) = 4 Typical 64-bit platform: Sizeof(x) = 32 Alignof(x) = 8 Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 Sizeof(x.c) = 24 Alignof(x.c) = 8 Offsetof(x.c) = 8

Despite their names, these functions are not in fact unsafe, and they may be helpful for understanding the layout of raw memory in a program when optimizing for space.





13.2 unsafe.Pointer


Most pointer types are written *T, meaning “a pointer to a variable of type T.” The unsafe.Pointer type is a special kind of pointer that can hold the address of any variable. Of course, we can’t indirect through an unsafe.Pointer using *p because we don’t know what type that expression should have. Like ordinary pointers, unsafe.Pointers are comparable and may be compared with nil, which is the zero value of the type.

An ordinary *T pointer may be converted to an unsafe.Pointer, and an unsafe.Pointer may be converted back to an ordinary pointer, not necessarily of the same type *T. By converting a *float64 pointer to a *uint64, for instance, we can inspect the bit pattern of a floating-point variable:

Click here to view code image

package math func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) } fmt.Printf("%#016x\n", Float64bits(1.0)) // "0x3ff0000000000000"

Through the resulting pointer, we can update the bit pattern too. This is harmless for a floating-point variable since any bit pattern is legal, but in general, unsafe.Pointer conversions let us write arbitrary values to memory and thus subvert the type system.

An unsafe.Pointer may also be converted to a uintptr that holds the pointer’s numeric value, letting us perform arithmetic on addresses. (Recall from Chapter 3 that a uintptr is an unsigned integer wide enough to represent an address.) This conversion too may be applied in reverse, but again, converting from a uintptr to an unsafe.Pointer may subvert the type system since not all numbers are valid addresses.

Many unsafe.Pointer values are thus intermediaries for converting ordinary pointers to raw numeric addresses and back again. The example below takes the address of variable x, adds the offset of its b field, converts the resulting address to *int16, and through that pointer updates x.b:

Click here to view code image

gopl.io/ch13/unsafeptr

var x struct { a bool b int16 c []int } // equivalent to pb := &x.b pb := (*int16)(unsafe.Pointer( uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b))) *pb = 42 fmt.Println(x.b) // "42"

Although the syntax is cumbersome—perhaps no bad thing since these features should be used sparingly—do not be tempted to introduce temporary variables of type uintptr to break the lines. This code is incorrect:

Click here to view code image

// NOTE: subtly incorrect! tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b) pb := (*int16)(unsafe.Pointer(tmp)) *pb = 42

The reason is very subtle. Some garbage collectors move variables around in memory to reduce fragmentation or bookkeeping. Garbage collectors of this kind are known as moving GCs. When a variable is moved, all pointers that hold the address of the old location must be updated to point to the new one. From the perspective of the garbage collector, an unsafe.Pointer is a pointer and thus its value must change as the variable moves, but a uintptr is just a number so its value must not change. The incorrect code above hides a pointer from the garbage collector in the non-pointer variable tmp. By the time the second statement executes, the variable x could have moved and the number in tmp would no longer be the address &x.b. The third statement clobbers an arbitrary memory location with the value 42.

There are myriad pathological variations on this theme. After this statement has executed:

Click here to view code image

pT := uintptr(unsafe.Pointer(new(T))) // NOTE: wrong!

there are no pointers that refer to the variable created by new, so the garbage collector is entitled to recycle its storage when this statement completes, after which pT contains the address where the variable was but is no longer.

No current Go implementation uses a moving garbage collector (though future implementations might), but this is no reason for complacency: current versions of Go do move some variables around in memory. Recall from Section 5.2 that goroutine stacks grow as needed. When this happens, all variables on the old stack may be relocated to a new, larger stack, so we cannot rely on the numeric value of a variable’s address remaining unchanged throughout its lifetime.

At the time of writing, there is little clear guidance on what Go programmers may rely upon after an unsafe.Pointer to uintptr conversion (see Go issue 7192), so we strongly recommend that you assume the bare minimum. Treat all uintptr values as if they contain the former address of a variable, and minimize the number of operations between converting an unsafe.Pointer to a uintptr and using that uintptr. In our first example above, the three operations—conversion to a uintptr, addition of the field offset, conversion back—all appeared within a single expression.

When calling a library function that returns a uintptr, such as those below from the reflect package, the result should be immediately converted to an unsafe.Pointer to ensure that it continues to point to the same variable.

Click here to view code image

package reflect func (Value) Pointer() uintptr func (Value) UnsafeAddr() uintptr func (Value) InterfaceData() [2]uintptr // (index 1)





13.3 Example: Deep Equivalence


The DeepEqual function from the reflect package reports whether two values are “deeply” equal. DeepEqual compares basic values as if by the built-in == operator; for composite values, it traverses them recursively, comparing corresponding elements. Because it works for any pair of values, even ones that are not comparable with ==, it finds widespread use in tests. The following test uses DeepEqual to compare two []string values:

Click here to view code image

func TestSplit(t *testing.T) { got := strings.Split("a:b:c", ":") want := []string{"a", "b", "c"}; if !reflect.DeepEqual(got, want) { /* ... */ } }

Although DeepEqual is convenient, its distinctions can seem arbitrary. For example, it doesn’t consider a nil map equal to a non-nil empty map, nor a nil slice equal to a non-nil empty one:

Click here to view code image

var a, b []string = nil, []string{} fmt.Println(reflect.DeepEqual(a, b)) // "false" var c, d map[string]int = nil, make(map[string]int) fmt.Println(reflect.DeepEqual(c, d)) // "false"

In this section we’ll define a function Equal that compares arbitrary values. Like DeepEqual, it compares slices and maps based on their elements, but unlike DeepEqual, it considers a nil slice (or map) equal to a non-nil empty one. The basic recursion over the arguments can be done with reflection, using a similar approach to the Display program we saw in Section 12.3. As usual, we define an unexported function, equal, for the recursion. Don’t worry about the seen parameter just yet. For each pair of values x and y to be compared, equal checks that both (or neither) are valid and checks that they have the same type. The result of the function is defined as a set of switch cases that compare two values of the same type. For reasons of space, we’ve omitted several cases since the pattern should be familiar by now.

Click here to view code image

gopl.io/ch13/equal

func equal(x, y reflect.Value, seen map[comparison]bool) bool { if !x.IsValid() || !y.IsValid() { return x.IsValid() == y.IsValid() } if x.Type() != y.Type() { return false } // ...cycle check omitted (shown later)... switch x.Kind() { case reflect.Bool: return x.Bool() == y.Bool() case reflect.String: return x.String() == y.String() // ...numeric cases omitted for brevity... case reflect.Chan, reflect.UnsafePointer, reflect.Func: return x.Pointer() == y.Pointer() case reflect.Ptr, reflect.Interface: return equal(x.Elem(), y.Elem(), seen) case reflect.Array, reflect.Slice: if x.Len() != y.Len() { return false } for i := 0; i < x.Len(); i++ { if !equal(x.Index(i), y.Index(i), seen) { return false } } return true // ...struct and map cases omitted for brevity... } panic("unreachable") }

As usual, we don’t expose the use of reflection in the API, so the exported function Equal must call reflect.ValueOf on its arguments:

Click here to view code image

// Equal reports whether x and y are deeply equal. func Equal(x, y interface{}) bool { seen := make(map[comparison]bool) return equal(reflect.ValueOf(x), reflect.ValueOf(y), seen) } type comparison struct { x, y unsafe.Pointer t reflect.Type }

To ensure that the algorithm terminates even for cyclic data structures, it must record which pairs of variables it has already compared and avoid comparing them a second time. Equal allocates a set of comparison structs, each holding the address of two variables (represented as unsafe.Pointer values) and the type of the comparison. We need to record the type in addition to the addresses because different variables can have the same address. For example, if x and y are both arrays, x and x[0] have the same address, as do y and y[0], and it is important to distinguish whether we have compared x and y or x[0] and y[0].

Once equal has established that its arguments have the same type, and before it executes the switch, it checks whether it is comparing two variables it has already seen and, if so, terminates the recursion.

Click here to view code image

// cycle check if x.CanAddr() && y.CanAddr() { xptr := unsafe.Pointer(x.UnsafeAddr()) yptr := unsafe.Pointer(y.UnsafeAddr()) if xptr == yptr { return true // identical references } c := comparison{xptr, yptr, x.Type()} if seen[c] { return true // already seen } seen[c] = true }

Here’s our Equal function in action:

Click here to view code image

fmt.Println(Equal([]int{1, 2, 3}, []int{1, 2, 3})) // "true" fmt.Println(Equal([]string{"foo"}, []string{"bar"})) // "false" fmt.Println(Equal([]string(nil), []string{})) // "true" fmt.Println(Equal(map[string]int(nil), map[string]int{})) // "true"

It even works on cyclic inputs similar to the one that caused the Display function from Section 12.3 to get stuck in a loop:

Click here to view code image

// Circular linked lists a -> b -> a and c -> c. type link struct { value string tail *link } a, b, c := &link{value: "a"}, &link{value: "b"}, &link{value: "c"} a.tail, b.tail, c.tail = b, a, c fmt.Println(Equal(a, a)) // "true" fmt.Println(Equal(b, b)) // "true" fmt.Println(Equal(c, c)) // "true" fmt.Println(Equal(a, b)) // "false" fmt.Println(Equal(a, c)) // "false"

Exercise 13.1: Define a deep comparison function that considers numbers (of any type) equal if they differ by less than one part in a billion.

Exercise 13.2: Write a function that reports whether its argument is a cyclic data structure.





13.4 Calling C Code with cgo


A Go program might need to use a hardware driver implemented in C, query an embedded database implemented in C++, or use some linear algebra routines implemented in Fortran. C has long been the lingua franca of programming, so many packages intended for widespread use export a C-compatible API, regardless of the language of their implementation.

In this section, we’ll build a simple data compression program that uses cgo, a tool that creates Go bindings for C functions. Such tools are called foreign-function interfaces (FFIs), and cgo is not the only one for Go programs. SWIG (swig.org) is another; it provides more complex features for integrating with C++ classes, but we won’t show it here.

The compress/... subtree of the standard library provides compressors and decompressors for popular compression algorithms, including LZW (used by the Unix compress command) and DEFLATE (used by the GNU gzip command). The APIs of these packages vary slightly in details, but they all provide a wrapper for an io.Writer that compresses the data written to it, and a wrapper for an io.Reader that decompresses the data read from it. For example:

Click here to view code image

package gzip // compress/gzip func NewWriter(w io.Writer) io.WriteCloser func NewReader(r io.Reader) (io.ReadCloser, error)



The bzip2 algorithm, which is based on the elegant Burrows-Wheeler transform, runs slower than gzip but yields significantly better compression. The compress/bzip2 package provides a decompressor for bzip2, but at the moment the package provides no compressor. Building one from scratch is a substantial undertaking, but there is a well-documented and high-performance open-source C implementation, the libbzip2 package from bzip.org.

If the C library were small, we would just port it to pure Go, and if its performance were not critical for our purposes, we would be better off invoking a C program as a helper subprocess using the os/exec package. It’s when you need to use a complex, performance-critical library with a narrow C API that it may make sense to wrap it using cgo. For the rest of this chapter, we’ll work through an example.

From the libbzip2 C package, we need the bz_stream struct type, which holds the input and output buffers, and three C functions: BZ2_bzCompressInit, which allocates the stream’s buffers; BZ2_bzCompress, which compresses data from the input buffer to the output buffer; and BZ2_bzCompressEnd, which releases the buffers. (Don’t worry about the mechanics of the libbzip2 package; the purpose of this example is to show how the parts fit together.)

We’ll call the BZ2_bzCompressInit and BZ2_bzCompressEnd C functions directly from Go, but for BZ2_bzCompress, we’ll define a wrapper function in C, to show how it’s done. The C source file below lives alongside the Go code in our package:

Click here to view code image

gopl.io/ch13/bzip

/* This file is gopl.io/ch13/bzip/bzip2.c, */ /* a simple wrapper for libbzip2 suitable for cgo. */ #include <bzlib.h> int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) { s->next_in = in; s->avail_in = *inlen; s->next_out = out; s->avail_out = *outlen; int r = BZ2_bzCompress(s, action); *inlen -= s->avail_in; *outlen -= s->avail_out; return r; }



Now let’s turn to the Go code, the first part of which is shown below. The import "C" declaration is special. There is no package C, but this import causes go build to preprocess the file using the cgo tool before the Go compiler sees it.

Click here to view code image

// Package bzip provides a writer that uses bzip2 compression (bzip.org). package bzip /* #cgo CFLAGS: -I/usr/include #cgo LDFLAGS: -L/usr/lib -lbz2 #include <bzlib.h> int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen); */ import "C" import ( "io" "unsafe" ) type writer struct { w io.Writer // underlying output stream stream *C.bz_stream outbuf [64 * 1024]byte } // NewWriter returns a writer for bzip2-compressed streams. func NewWriter(out io.Writer) io.WriteCloser { const ( blockSize = 9 verbosity = 0 workFactor = 30 ) w := &writer{w: out, stream: new(C.bz_stream)} C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor) return w }



During preprocessing, cgo generates a temporary package that contains Go declarations corresponding to all the C functions and types used by the file, such as C.bz_stream and C.BZ2_bzCompressInit. The cgo tool discovers these types by invoking the C compiler in a special way on the contents of the comment that precedes the import declaration.

The comment may also contain #cgo directives that specify extra options to the C toolchain. The CFLAGS and LDFLAGS values contribute extra arguments to the compiler and linker commands so that they can locate the bzlib.h header file and the libbz2.a archive library. The example assumes that these are installed beneath /usr on your system. You may need to alter or delete these flags for your installation.

NewWriter makes a call to the C function BZ2_bzCompressInit to initialize the buffers for the stream. The writer type includes another buffer that will be used to drain the decompressor’s output buffer.

The Write method, shown below, feeds the uncompressed data to the compressor, calling the function bz2compress in a loop until all the data has been consumed. Observe that the Go program may access C types like bz_stream, char, and uint, C functions like bz2compress, and even object-like C preprocessor macros such as BZ_RUN, all through the C.x notation. The C.uint type is distinct from Go’s uint type, even if both have the same width.

Click here to view code image

func (w *writer) Write(data []byte) (int, error) { if w.stream == nil { panic("closed") } var total int // uncompressed bytes written for len(data) > 0 { inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf)) C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(&data[0])), &inlen, (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen) total += int(inlen) data = data[inlen:] if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return total, err } } return total, nil }

Each iteration of the loop passes bz2compress the address and length of the remaining portion of data, and the address and capacity of w.outbuf. The two length variables are passed by their addresses, not their values, so that the C function can update them to indicate how much uncompressed data was consumed and how much compressed data was produced. Each chunk of compressed data is then written to the underlying io.Writer.

The Close method has a similar structure to Write, using a loop to flush out any remaining compressed data from the stream’s output buffer.

Click here to view code image

// Close flushes the compressed data and closes the stream. // It does not close the underlying io.Writer. func (w *writer) Close() error { if w.stream == nil { panic("closed") } defer func() { C.BZ2_bzCompressEnd(w.stream) w.stream = nil }() for { inlen, outlen := C.uint(0), C.uint(cap(w.outbuf)) r := C.bz2compress(w.stream, C.BZ_FINISH, nil, &inlen, (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen) if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return err } if r == C.BZ_STREAM_END { return nil } } }

Upon completion, Close calls C.BZ2_bzCompressEnd to release the stream buffers, using defer to ensure that this happens on all return paths. At this point the w.stream pointer is no longer safe to dereference. To be defensive, we set it to nil, and add explicit nil checks to each method, so that the program panics if the user mistakenly calls a method after Close. Not only is writer not concurrency-safe, but concurrent calls to Close and Write could cause the program to crash in C code. Fixing this is Exercise 13.3.

The program below, bzipper, is a bzip2 compressor command that uses our new package. It behaves like the bzip2 command present on many Unix systems.

Click here to view code image

gopl.io/ch13/bzipper

// Bzipper reads input, bzip2-compresses it, and writes it out. package main import ( "io" "log" "os" "gopl.io/ch13/bzip" ) func main() { w := bzip.NewWriter(os.Stdout) if _, err := io.Copy(w, os.Stdin); err != nil { log.Fatalf("bzipper: %v\n", err) } if err := w.Close(); err != nil { log.Fatalf("bzipper: close: %v\n", err) } }



In the session below, we use bzipper to compress /usr/share/dict/words, the system dictionary, from 938,848 bytes to 335,405 bytes—about a third of its original size—then uncompress it with the system bunzip2 command. The SHA256 hash is the same before and after, giving us confidence that the compressor is working correctly. (If you don’t have sha256sum on your system, use your solution to Exercise 4.2.)

Click here to view code image

$ go build gopl.io/ch13/bzipper $ wc -c < /usr/share/dict/words 938848 $ sha256sum < /usr/share/dict/words 126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed - $ ./bzipper < /usr/share/dict/words | wc -c 335405 $ ./bzipper < /usr/share/dict/words | bunzip2 | sha256sum 126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -

We’ve demonstrated linking a C library into a Go program. Going in the other direction, it’s also possible to compile a Go program as a static archive that can be linked into a C program or as a shared library that can be dynamically loaded by a C program. We’ve only scratched the surface of cgo here, and there is much more to say about memory management, pointers, callbacks, signal handling, strings, errno, finalizers, and the relationship between goroutines and operating system threads, much of it very subtle. In particular, the rules for correctly passing pointers from Go to C or vice versa are complex, for reasons similar to those we discussed in Section 13.2, and not yet authoritatively specified. For further reading, start with https://golang.org/cmd/cgo.

Exercise 13.3: Use sync.Mutex to make bzip2.writer safe for concurrent use by multiple goroutines.

Exercise 13.4: Depending on C libraries has its drawbacks. Provide an alternative pure-Go implementation of bzip.NewWriter that uses the os/exec package to run /bin/bzip2 as a subprocess.





13.5 Another Word of Caution


We ended the previous chapter with a warning about the downsides of the reflection interface. That warning applies with even more force to the unsafe package described in this chapter.

High-level languages insulate programs and programmers not only from the arcane specifics of individual computer instruction sets, but from dependence on irrelevancies like where in memory a variable lives, how big a data type is, the details of structure layout, and a host of other implementation details. Because of that insulating layer, it’s possible to write programs that are safe and robust and that will run on any operating system without change.

The unsafe package lets programmers reach through the insulation to use some crucial but otherwise inaccessible feature, or perhaps to achieve higher performance. The cost is usually to portability and safety, so one uses unsafe at one’s peril. Our advice on how and when to use unsafe parallels Knuth’s comments on premature optimization, which we quoted in Section 11.5. Most programmers will never need to use unsafe at all. Nevertheless, there will occasionally be situations where some critical piece of code can be best written using unsafe. If careful study and measurement indicates that unsafe really is the best approach, restrict it to as small a region as possible, so that most of the program is oblivious to its use.

For now, put the last two chapters in the back of your mind. Write some substantial Go programs. Avoid reflect and unsafe; come back to these chapters only if you must.

Meanwhile, happy Go programming. We hope you enjoy writing Go as much as we do.





Index


A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

, -= , etc., assignment operator +=, 1.2

-= , etc., assignment operator += , , 1.2

| in template, 4.6

. in template, dot , 4.6

:= short variable declaration, 1.2, 2.3.1, 2.7

&, address-of operator, 1.8, 2.3.2, 2.3.2, 2.3.2, 4.3, 6.2, 6.5

&^, AND-NOT operator, 3.1

... argument, 5.6, 5.7

... array length, 4.1

` backquote character, 3.5.1

&^, bit-clear operator, 3.1

^, bitwise complement operator, 3.1

|, bitwise OR operator, 6.5, 6.5

_, blank identifier, 1.2, 2.4.1, 4.3, 5.1, 5.3, 10.5

// comment, 1.2

// comment, 1.8

==, comparison operator, 2.5, 3.4

--, decrement statement, 1.2, 2.4

, etc., assignment operator += , -=, 1.2

^, exclusive OR operator, 3.1

&, implicit, 6.2, 6.5

*, indirection operator, 1.8, 2.3.2

<<, left shift operator, 3.1

!, negation operator, 3.4

// Output comment, 11.6

... parameter, 4.2.1, 5.7, 5.7, 7.1

... path, 10.7.2, 10.7.6

' quote character, 3.1

%, remainder operator, 3.1, 6.5

>>, right shift operator, 3.1

&&, short-circuit AND operator, 3.4

||, short-circuit OR operator, 3.4

-, unary operator, 3.1

, Unicode replacement character , 3.5.3, 4.3

+= , -= , etc., assignment operator, 1.2

+, string concatenation operator, 1.2, 3.5

+, unary operator, 3.1

++, increment statement, 1.2, 2.4, 4.3

+build comments, 10.7.3




A

Abstract Syntax Notation One (ASN.1), 4.5

abstract type, 1.8, 7.1

abstraction, premature, 7.15, 11.2.5, 11.2.5

ad hoc polymorphism, 7.13

address of local variable, 2.3.2, 2.3.4

address of struct literal, 4.4.1

addressable expression, 6.2, 12.5

addressable value, 2.3.2

address-of operator &, 1.8, 2.3.2, 2.3.2, 2.3.2, 4.3, 6.2, 6.5

aggregate type, 4, 4.4

Alef programming language, Preface

algorithm, breadth-first search, 5.6, 8.6

algorithm, depth-first search, 5.6

algorithm, Fibonacci, 2.4.1, 8.1

algorithm, GCD, 2.4.1

algorithm, insertion sort, 4.4

algorithm, Lissajous, 1.4

algorithm, slice rotation, 4.2

algorithm, topological sort, 5.6

aliasing, pointer, 2.3.2

alignment, 13.1

allocation, heap, 2.3.4

allocation, memory, 2.3.4, 2.3.4, 3.5.4, 4.2.1, 6.6, 7.12, 11.4

allocation, stack, 2.3.4

anchor element, HTML, 5.2

AND operator &&, short-circuit, 3.4

AND-NOT operator &^, 3.1

animation, GIF, 1.4

anonymous function, 1.7, 5.6, 5.6, 8.5

anonymous function, defer, 5.8

anonymous function, recursive, 5.6

anonymous struct field, 4.4.3, 4.4.3, 4.4.3, 6.3

API, encoding, 7.14, 12.4

API, error, 5.4, 5.10

API, package, 10.1, 10.7.4, 11.2.3, 12.3, 12.9

API, runtime, 11.5

API, SQL, 7.13

API, system call, 7.8

API, template, 4.6

API, token-based decoder, 7.14, 7.14, 12.6

APL programming language, Preface

append built-in function, 4.2.1, 4.2.1, 4.2.1

appendInt example, 4.2.1

argument, ..., 5.6, 5.7

argument, command-line, 1.2, 1.6, 2.3.2, 2.6.1, 7.4, 7.4, 10.7, 11.2.3

argument, function, 5.1

argument, pointer, 2.3.2, 4.1

argument, slice, 4.2

arithmetic expression evaluator, 7.9

array comparison, 4.1

array length, ..., 4.1

array literal, 4.1, 4.1, 4.2

array type, 4.1

array, underlying, 4.2, 4.2, 4.2.1, 7.6

array zero value, 4.1

ASCII, 3.1, 3.5, 3.5.1, 3.5.2, 11.2

ASN.1 (Abstract Syntax Notation One), 4.5

assembly line, cake, 8.4.4

assertion function, 11.2.5

assertion, interface type, 7.12, 7.12

assertion, test, 11.2

assertion, type, 7.10, 7.13

assignability, 2.4.2, 2.4.2, 7.3

assignability, interface, 7.3

assignment, implicit, 2.4.2

assignment, multiple-value, 2.4.1

assignment operator += , -= , etc., 1.2

assignment operators, 2.4, 3.1

assignment statement, 1.2, 1.2, 2.4, 3.1, 4.3, 7.1

assignment, tuple, 2.3.1, 2.4.1

associativity, operator, 3.1

atomic operation, 9.2

attack, HTML injection, 4.6

attack, SQL injection, 7.13

autoescape example, 4.6




B

back-door, package, 11.2.4

back-off, exponential, 5.4.1

backquote character, `, 3.5.1

bank example package, 9.1, 9.1, 9.2

bare return, 5.3

basename example, 3.5.4, 3.5.4

behavior, undefined, 9.1

Benchmark function, 11.1, 11.4

bidirectional to unidirectional channel conversion, 8.4.3

binary operators, table of, 3.1

binary semaphore, 9.2

binary tree, 4.4

bit vector, 6.5

bit-clear operator &^, 3.1

bit-set data type, 3.6.1

bitwise complement operator ^, 3.1

bitwise operators, table of, 3.1

bitwise OR operator |, 6.5, 6.5

black-box test, 11.2.3

blank identifier _, 1.2, 2.4.1, 4.3, 5.1, 5.3, 10.5

blank import, 10.5

block, file, 2.7

block, lexical, 2.7, 5.1, 5.6, 5.6.1, 7.13

block, local, 2.7

block, package, 2.7

block, universe, 2.7

blocking profile, 11.5

Blog, Go, Preface, 11.5

boiling example, 2.2

bool type, 3.4

boolean constant, false, 3.4

boolean constant, true, 3.4

boolean zero value, 2.3

breadthFirst function, 5.6

breadth-first search algorithm, 5.6, 8.6

break statement, labeled, 8.8

break statement, 1.8, 2.7

brittle test, 11.2.6

broadcast, 8.9, 8.10, 9.7

Brooks, Fred, Preface

btoi function, 3.4

buffered channel, 8.4, 8.4.4

bufio package, 1.3

bufio.NewReader function, 4.3

bufio.NewScanner function, 1.3

(*bufio.Reader).ReadRune method, 4.3, 4.3

bufio.Scanner type, 1.3

(*bufio.Scanner).Err method, 4.3

(*bufio.Scanner).Scan method, 1.3

(*bufio.Scanner).Split method, 4.3

bufio.ScanWords function, 4.3

build constraints, 10.7.3

build tags, 10.7.3

building packages, 10.7.3

built-in function, append, 4.2.1, 4.2.1, 4.2.1

built-in function, cap, 4.2, 8.4.4

built-in function, close, 8.4, 8.4.2, 8.9

built-in function, complex, 3.3

built-in function, copy, 4.2.1

built-in function, delete, 4.3

built-in function, imag, 3.3

built-in function, len, 1.2, 3.1, 3.5, 3.5, 4.1, 4.2, 8.4.4

built-in function, make, 1.3, 1.6, 4.2, 4.3, 8.4

built-in function, new, 2.3.3

built-in function, panic, 5.9, 5.9

built-in function, real, 3.3

built-in function, recover, 5.10

built-in interface, error, 7.8, 7.8

built-in type, error, 1.3, 5.4, 5.9, 7.8

byte slice to string conversion, 3.5.4

byte type, 3.1

ByteCounter example, 7.1

bytes package, 3.5.4, 3.5.4

bytes.Buffer type, 3.5.4, 6.6, 7.1, 7.5.1

(*bytes.Buffer).Grow method, 6.6

(*bytes.Buffer).WriteByte method, 3.5.4

(*bytes.Buffer).WriteRune method, 3.5.4

(*bytes.Buffer).WriteString method, 3.5.4

bytes.Equal function, 4.2

bzip C code, 13.4

bzip example package, 13.4

bzipper example, 13.4




C

C programming language, Preface, Preface, 1.1, 1.2, 3.1, 9.1, 13.4

C++ programming language, Preface, Preface, 13.4

cache, concurrent non-blocking, 9.7

cache, non-blocking, 9.7

cake assembly line, 8.4.4

call by reference, 4.1

call by value, 4.1, 5.1, 6.2

call, interface method, 7.5

call, ok value from function, 5.4

calling C from Go, 13.4

camel case, 2.1

cancellation, 8.9, 8.9

cancellation of HTTP request, 8.9

cap built-in function, 4.2, 8.4.4

capacity, channel, 8.4, 8.4.4, 8.4.4

capacity, slice, 4.2, 4.2.1

capturing iteration variable, 5.6.1

capturing loop variable, 5.6.1, 8.5, 8.6

case in type switch, 7.13

case, select, 8.7

Celsius type, 2.5

CelsiusFlag function, 7.4

cf example, 2.6.1

cgo tool, 13.4, 13.4

<-ch, channel receive, 1.6, 8.4, 8.4.4

ch<-, channel send, 1.6, 8.4, 8.4.4

chaining, method, 4.6

<-chan T, receive-only channel type , 8.4.3

chan<- T, send-only channel type , 8.4.3

chan type, 8.4

channel, buffered, 8.4, 8.4.4

channel capacity, 8.4, 8.4.4, 8.4.4

channel close, 8.4.2, 8.9

channel, closing a, 8.4

channel communication, 8.4, 8.7

channel comparison, 8.4

channel conversion, bidirectional to unidirectional, 8.4.3

channel, draining a, 8.4.2, 8.9

channel, make, 1.6, 8.4

channel, nil, 8.7, 8.8

channel, polling, 8.7

channel, range over, 8.4.2

channel receive <-ch, 1.6, 8.4, 8.4.4

channel receive, non-blocking, 8.7

channel receive, ok value from, 8.4.2

channel send ch<-, 1.6, 8.4, 8.4.4

channel, synchronous, 8.4.1

channel type, 1.6

channel type <-chan T, receive-only, 8.4.3

channel type chan<- T, send-only, 8.4.3

channel type, unidirectional, 8.4.3, 8.4.3, 8.4.3

channel, unbuffered, 8.4, 8.4.1

channel zero value, 8.4, 8.7

character conversion, 3.5.4

character test, 3.5.4

charcount example, 4.3

chat example, 8.10

chat server, 8.10

CheckQuota function, 11.2.3, 11.2.3

client, email, 11.2.3

client, SMTP, 11.2.3

clock example, 8.2, 8.2

clock server, concurrent, 8.2

close built-in function, 8.4, 8.4.2, 8.9

close, channel, 8.4.2, 8.9

closer goroutine, 8.5, 8.8

closing a channel, 8.4

closure, lexical, 5.6

cmplx.Sqrt function, 3.3

code format, 1.1, 1.2, 1.3, 2.7

code point, Unicode, 3.5.2

code, production, 11

ColoredPoint example, 6.3

comma example, 3.5.4

command, testing a, 11.2.2

command-line argument, 1.2, 1.6, 2.3.2, 2.6.1, 7.4, 7.4, 10.7, 11.2.3

comment, //, 1.2

comment, //, 1.8

comment, // Output, 11.6

comment, doc, 2.6, 10.7.4

comments, +build, 10.7.3

communicating sequential processes (CSP), Preface, 8

communication, channel, 8.4, 8.7

comparability, 1.3, 2.4.2, 2.5, 3.1, 4.2, 4.3, 4.3, 4.4.2

comparison, array, 4.1

comparison, channel, 8.4

comparison, function, 5.5

comparison, interface, 7.5

comparison, map, 4.3

comparison operator ==, 2.5, 3.4

comparison operators, 2.5, 4.3

comparison operators, table of, 3.1

comparison, slice, 4.2

comparison, string, 3.5

comparison, struct, 4.4.2

compilation, separate, 10.1

complement operator ^, bitwise, 3.1

complex built-in function, 3.3

complex type, 3.3

composite literal, 1.4

composite type, Preface, 1.4, 4

composition, parallel, 8.3

composition, type, Preface, 4.4.3, 6.3, 7.6

compress/bzip2 package, 13.4

compression, 13.4

conceptual integrity, Preface

concrete type, 1.8, 7.1, 7.13, 7.14

concurrency, 1.6, 8, 9

concurrency, excessive, 8.6, 8.6

concurrency safe, 9.7

concurrency safety, 8.10, 9.1, 9.7, 13.4

concurrency with shared variables, 9

concurrent clock server, 8.2

concurrent directory traversal, 8.8

concurrent echo server, 8.3

concurrent non-blocking cache, 9.7

concurrent web crawler, 8.6

confinement, serial, 9.1

confinement, variable, 9.1

consistency, sequential, 9.4, 9.5

const declaration, 1.4, 3.6

constant, false boolean, 3.4

constant generator, iota, Preface, 3.6.1

constant, time.Minute, 3.6

constant, time.Second, 6.4

constant, true boolean, 3.4

constant types, untyped, 3.6.2

constants, precision of, 3.6.2

constraints, build, 10.7.3

contention, lock, 9.3, 9.7

context switch, 9.8.2

continue statement, labeled, 8.8

continue statement, 1.8, 2.7

contracts, interfaces as, 7.1

control flow, 2.7

conversion, bidirectional to unidirectional channel, 8.4.3

conversion, byte slice to string, 3.5.4

conversion, character, 3.5.4

conversion, implicit, 3.6.2

conversion, narrowing, 2.5, 3.1

conversion, numeric, 3.6.2

conversion operation, 2.5, 3.1, 3.1, 3.1, 3.4, 3.5.3, 3.6.2, 3.6.2, 7.1, 7.6, 7.7, 7.12, 8.4.3, 13, 13.2

conversion, rune slice to string, 3.5.3

conversion, rune to string, 3.5.3

conversion, string, 3.5.4

conversion, string to byte slice, 2.5, 3.5.4

conversion, string to rune slice, 3.5.3, 4.2.1

conversion, unsafe.Pointer, 13.2

copy built-in function, 4.2.1

countdown example, 8.7, 8.7, 8.7, 8.7

counting semaphore, 8.6

coverage, statement, 11.3, 11.3

coverage, test, 11.3

coverage_test example, 11.3

CPU profile, 11.5

crawl example, 8.6, 8.6, 8.6, 8.6

crawler, concurrent web, 8.6

crawler, web, 5

critical section, 9.2, 9.5, 9.7

cross-compilation, 10.7.3

cryptography, 3.1, 4.1, 5.2, 11.5

crypto/sha256 package, 4.1

customSort example, 7.6

cyclic data structure, 12.3

cyclic test dependency, 11.2.4




D

data race, 9.1, 9.4, 9.7

data structure, cyclic, 12.3

data structure, recursive, 4.4, 4.4, 4.5

data type, bit-set, 3.6.1

database driver, MySQL, 10.2

database/sql package, 7.13, 10.5

daysAgo function, 4.6

deadbeef, 3.1, 3.6.2

deadlock, 8.4.4, 8.6, 9.2

declaration, const, 1.4, 3.6

declaration, func, 1.1, 2.2, 5.1

declaration, import, 1.1, 2.2, 2.6.1, 10.2, 10.4, 13.4

declaration, method, 2.5, 6.1

declaration, package, 1.1, 2.2, 2.6, 10.3

declaration, package-level, 2.2

declaration scope, 2.7, 5.6

declaration, shadowing, 2.7, 2.7, 7.10, 7.13

declaration, short variable, 1.2, 1.2, 2.3.1, 2.3.1

declaration statement, short variable, 1.2

declaration, struct, 4.4

declaration, type, 2.5

declaration, var, 1.2, 2.3

declarations, order of, 2.7

decode example, S-expression, 12.6

decoder API, token-based, 7.14, 7.14, 12.6

decoding, S-expression, 12.6

decoding, XML, 7.14

decrement statement --, 1.2, 2.4

dedup example, 4.3

deep equivalence, 4.2, 11.2.5, 13.3

default case in select, 8.7

default case in switch, 1.8

default case in type switch, 7.13

defer anonymous function, 5.8

defer example, 5.9, 5.9

defer statement, 5.8, 5.9, 9.2

deferred function call, 5.8

delete built-in function, 4.3

depth-first search algorithm, 5.6

dereference, implicit, 6.2

diagram, helloworld substring, 3.5.3

diagram, pipeline, 8.4.2

diagram, slice capacity growth, 4.2.1

diagram, slice of months, 4.2

diagram, string sharing, 3.5

diagram, struct hole, 13.1

diagram, thumbnail sequence, 8.5

digital artifact example, 7.3

Dijkstra, Edsger, 11.3

Dilbert, 4.4

directed acyclic graph, 5.6, 10.1

directory traversal, concurrent, 8.8

discriminated union, 7.13, 7.13, 7.14

display example, 12.3

Display function, 12.3

display function, 12.3

displaying methods of a type, 12.8

Distance function, 6.1

doc comment, 2.6, 10.7.4

doc.go doc comment file, 2.6, 10.7.4

documentation, package, 10.7.4

domain name, import path, 10.2

dot . in template, 4.6

downloading packages, 10.7.2

Dr. Strangelove, 12.3

draining a channel, 8.4.2, 8.9

du example, 8.8, 8.8, 8.8

dup example, 1.3, 1.3, 1.3

duplicate suppression, 9.7

dynamic dispatch, 7.5

dynamic type, interface, 7.5




E

echo example, 1.2, 1.2, 2.3.2, 11.2.2

echo server, concurrent, 8.3

echo test, 11.2.2

echo_test.go, 11.2.2

effective tests, writing, 11.2.5, 11.2.6

email client, 11.2.3

embarrassingly parallel, 8.5

embedded struct field, 6.3

embedding, interface, 7.2

embedding, struct, 4.4.3, 6.3

Employee struct, 4.4

empty select statement, 8.7

empty interface type, 7.3

empty string, 1.2, 1.2, 2.3

empty struct, 4.4

encapsulation, 6.6, 10.1

encoding API, 7.14, 12.4

encoding, S-expression, 12.4, 12.4

encoding/json package, 4.5

encoding/xml package, 4.5, 7.14

end of file (EOF), 5.4.2

enum, 3.6.1

environment variable, GOARCH, 10.7.1, 10.7.3

environment variable, GOMAXPROCS, 9.8.3, 11.4

environment variable, GOOS, 10.7.1, 10.7.3

environment variable, GOPATH, Preface, 10.7.1, 10.7.3

environment variable, GOROOT, 10.7.1

equal function, 4.2, 4.3

equality, pointer, 2.3.2

equivalence, deep, 4.2, 11.2.5, 13.3

error API, 5.4, 5.10

error built-in interface, 7.8, 7.8

error built-in type, 1.3, 5.4, 5.9, 7.8

error.Error method, 7.8

errorf function, 5.7

error-handling strategies, 5.4.1, 5.10, 11.2.2, 11.2.5

errors package, 7.8

errors.New function, 7.8

escape, hexadecimal, 3.5.1

escape, HTML, 4.6

escape, octal, 3.5.1

escape sequence, 1.3

escape sequences, table of, 3.5.1

escape, Unicode, 3.5.3, 4.5

escape, URL, 4.5

escaping variables, 2.3.4

eval example, 7.9, 7.9

event multiplexing, 8.7

events, 8.4.1, 8.7

example, appendInt, 4.2.1

example, autoescape, 4.6

example, basename, 3.5.4, 3.5.4

example, boiling, 2.2

example, ByteCounter, 7.1

example, bzipper, 13.4

example, cf, 2.6.1

example, charcount, 4.3

example, chat, 8.10

example, clock, 8.2, 8.2

example, ColoredPoint, 6.3

example, comma, 3.5.4

example, countdown, 8.7, 8.7, 8.7, 8.7

example, coverage_test, 11.3

example, crawl, 8.6, 8.6, 8.6, 8.6

example, customSort, 7.6

example, dedup, 4.3

example, defer, 5.9, 5.9

example, digital artifact, 7.3

example, display, 12.3

example, du, 8.8, 8.8, 8.8

example, dup, 1.3, 1.3, 1.3

example, echo, 1.2, 1.2, 2.3.2, 11.2.2

example, eval, 7.9, 7.9

example, fetch, 1.5, 5.8

example, fetchall, 1.6

example, findlinks, 5.2, 5.3, 5.6

example, ftoc, 2.2

Example function, 11.1, 11.6

example, github, 4.5, 4.5

example, graph, 4.3

example, helloworld, 1.1, 1.1

example, http, 7.7, 7.7, 7.7, 7.7

example, intset, 6.5, 6.5

example, issues, 4.5

example, issueshtml, 4.6

example, issuesreport, 4.6

example, jpeg, 10.5

example, lissajous, 1.4, 1.7, 2.3.4

example, mandelbrot, 3.3

example, memo, 9.7, 9.7, 9.7, 9.7, 9.7, 9.7

example, methods, 12.8

example, movie, 4.5, 4.5

example, netcat, 8.2, 8.3, 8.4.1

example, netflag, 3.6.1

example, nonempty, 4.2.2

example, outline, 5.2, 5.5

example package, bank, 9.1, 9.1, 9.2

example package, bzip, 13.4

example package, format, 12.2

example package, geometry, 6.1

example package, http, 7.7

example package, links, 5.6

example package, memo, 9.7

example package, params, 12.7

example package, storage, 11.2.3, 11.2.3

example package, tempconv, 2.6

example package, thumbnail, 8.5

example, palindrome, 11.2, 11.2, 11.2.1

example, params, 12.7

example, Parse, 5.10

example, pipeline, 8.4.2, 8.4.2, 8.4.3

example, playlist, 7.6

example, rev, 4.2

example, reverb, 8.3, 8.3

example, server, 1.7, 1.7, 1.7

example, sexpr, 12.4

example, S-expression decode, 12.6

example, sha256, 4.1

example, sleep, 7.4

example, spinner, 8.1

example, squares, 5.6

example, sum, 5.7

example, surface, 3.2, 7.9

example, tempconv, 2.5, 7.4, 10.6

example, temperature conversion, 2.2

example, tempflag, 7.4

example, test of word, 11.2

example, thumbnail, 8.5, 8.5, 8.5

example, title, 5.10

example, topoSort, 5.6

example, trace, 5.8

example, treesort, 4.4

example, urlvalues, 6.2.1

example, wait, 5.4.1

example, word, 11.2, 11.2, 11.2.1

example, xmlselect, 7.14

exception, 5.4, 5.9

excessive concurrency, 8.6, 8.6

exclusion, mutual, 9.1, 9.2, 9.4

exclusive lock, 9.2, 9.3, 9.5

exclusive OR operator ^, 3.1

exponential back-off, 5.4.1

export of struct field, 4.4, 4.4.3, 4.5, 4.5, 6.6

export_test.go file, 11.2.4

Expr.Check method, 7.9

expression, addressable, 6.2, 12.5

expression evaluator, 7.9

expression, method, 6.4

expression, receive, 8.4

Expr.Eval method, 7.9

extending a slice, 4.2

Extensible Markup Language (XML), 4.5

external test package, 10.3, 11.2.4




F

Fahrenheit type, 2.5

failure message, test, 11.2

fallthrough statement, 1.8, 7.13

false boolean constant, 3.4

fetch example, 1.5, 5.8

fetchall example, 1.6

fib function, 2.4.1, 8.1

Fibonacci algorithm, 2.4.1, 8.1

field, anonymous struct, 4.4.3, 4.4.3, 4.4.3, 6.3

field, embedded struct, 6.3

field, export of struct, 4.4, 4.4.3, 4.5, 4.5, 6.6

field order, struct, 4.4, 13.1

field selector, 6.1

field, struct, 1.4, 4.4

field tag, omitempty, 4.5

field tag, struct, 4.5, 12.7

figure, Lissajous, 1.4

figure, Mandelbrot, 3.3

figure, three-D surface, 3.2, 7.9

file block, 2.7

file, export_test.go, 11.2.4

file name, Microsoft Windows, 3.5.4

file name, POSIX, 3.5.4

file, _test.go, 10.3, 11.1, 11.2

File Transfer Protocol (FTP), 8.2

findlinks example, 5.2, 5.3, 5.6

fixed-size stack, 5.2

flag, go list -f, 11.2.4

flag, go -race, 9.6

flag, go test -race, 9.7

flag, go test -run, 11.2

flag, go test -v, 11.2

flag, go tool -bench, 11.4

flag, go tool -benchmem, 11.4

flag, go tool -covermode, 11.3

flag, go tool -coverprofile, 11.3

flag, go tool -cpuprofile, 11.5

flag, go tool -nodecount, 11.5

flag, go tool -text, 11.5

flag, go tool -web, 11.5

flag, godoc -analysis, 7.3

flag package, 2.3.2, 7.4

flag.Args function, 2.3.2

flag.Bool function, 2.3.2

flag.Duration function, 7.4

flag.Parse function, 2.3.2

flag.String function, 2.3.2

flag.Value interface, 7.4, 7.4

floating-point number, 3.2

floating-point precision, 3.2, 3.2, 3.3, 3.6.2

floating-point truncation, 2.5, 3.1

fmt package, 1.1

fmt.Errorf function, 5.4.1, 7.8

fmt.Fprintf function, 7.1

fmt.Printf function, 1.3

fmt.Println function, 1.1

fmt.Scanf function, 3.5.5

fmt.Sscanf function, 7.4

fmt.Stringer interface, 7.4, 7.12

for scope, 2.7

for statement, 1.2

forEachNode function, 5.5

foreign-function interface (FFI), 13.4

format, code, 1.1, 1.2, 1.3, 2.7

format example package, 12.2

formatAtom function, 12.2

framework, web, 7.7

ftoc example, 2.2

func declaration, 1.1, 2.2, 5.1

function, anonymous, 1.7, 5.6, 5.6, 8.5

function, append built-in, 4.2.1, 4.2.1, 4.2.1

function argument, 5.1

function, assertion, 11.2.5

function, Benchmark, 11.1, 11.4

function body, missing, 5.1

function, breadthFirst, 5.6

function, btoi, 3.4

function, bufio.NewReader, 4.3

function, bufio.NewScanner, 1.3

function, bufio.ScanWords, 4.3

function, bytes.Equal, 4.2

function call, deferred, 5.8

function call, ok value from, 5.4

function, cap built-in, 4.2, 8.4.4

function, CelsiusFlag, 7.4

function, CheckQuota, 11.2.3, 11.2.3

function, close built-in, 8.4, 8.4.2, 8.9

function, cmplx.Sqrt, 3.3

function comparison, 5.5

function, complex built-in, 3.3

function, copy built-in, 4.2.1

function, daysAgo, 4.6

function, delete built-in, 4.3

function, Display, 12.3

function, display, 12.3

function, Distance, 6.1

function, equal, 4.2, 4.3

function, errorf, 5.7

function, errors.New, 7.8

function, Example, 11.1, 11.6

function, fib, 2.4.1, 8.1

function, flag.Args, 2.3.2

function, flag.Bool, 2.3.2

function, flag.Duration, 7.4

function, flag.Parse, 2.3.2

function, flag.String, 2.3.2

function, fmt.Errorf, 5.4.1, 7.8

function, fmt.Fprintf, 7.1

function, fmt.Printf, 1.3

function, fmt.Println, 1.1

function, fmt.Scanf, 3.5.5

function, fmt.Sscanf, 7.4

function, forEachNode, 5.5

function, formatAtom, 12.2

function, gcd, 2.4.1

function, handler, 1.7, 1.7, 5.10, 7.7, 7.7, 7.7, 12.7

function, html.Parse, 5.2, 5.3

function, http.DefaultServeMux, 7.7

function, http.Error, 7.7

function, http.Get, 1.5, 1.6

function, http.Handle, 7.7

function, http.HandleFunc, 1.7, 1.7, 7.7

function, http.ListenAndServe, 1.7, 7.7

function, http.NewRequest, 8.9

function, http.ServeMux, 7.7

function, hypot, 5.1

function, imag built-in, 3.3

function, image.Decode, 10.5

function, image.RegisterFormat, 10.5

function, incr, 2.3.2

function, init, 2.6.2, 2.7

function, intsToString, 3.5.4

function, io.Copy, 1.5, 1.6

function, ioutil.ReadAll, 1.5, 9.7

function, ioutil.ReadDir, 8.8

function, ioutil.ReadFile, 1.3, 5.8

function, io.WriteString, 7.12

function, itob, 3.4

function, json.Marshal, 4.5

function, json.MarshalIndent, 4.5

function, json.NewDecoder, 4.5

function, json.NewEncoder, 4.5

function, json.Unmarshal, 4.5, 4.6

function, len built-in, 1.2, 3.1, 3.5, 3.5, 4.1, 4.2, 8.4.4

function, links.Extract, 5.6

function literal, 1.7, 5.6, 8.4.1

function, log.Fatalf, 2.7, 5.4.1

function, main, 1.1, 11.2.2

function, make built-in, 1.3, 1.6, 4.2, 4.3, 8.4

function, math.Hypot, 6.1

function, math.Inf, 3.2

function, math.IsInf, 3.2

function, math.IsNaN, 3.2

function, math.NaN, 3.2

function, multi-valued, 1.3, 2.3, 2.4.1, 4.3, 5.3, 5.3

function, mustCopy, 8.2

function, net.Dial, 8.2

function, net.Listen, 8.2

function, new built-in, 2.3.3

function, nil, 5.5

function, os.Close, 1.3

function, os.Exit, 1.5, 2.3.2, 2.7

function, os.Getwd, 2.7

function, os.IsExist, 7.11

function, os.IsNotExist, 7.11

function, os.IsPermission, 7.11

function, os.Open, 1.3

function, os.Stat, 8.8

function, panic built-in, 5.9, 5.9

function parameter, 5.1

function, params.Unpack, 12.7

function, png.Encode, 3.3

function, PopCount, 2.6.2

function, real built-in, 3.3

function, recover built-in, 5.10

function, recursive anonymous, 5.6

function, reflect.TypeOf, 12.2

function, reflect.ValueOf, 12.2, 12.2, 12.3

function, reflect.Zero, 12.6

function, regexp.Compile, 5.9

function, regexp.MustCompile, 5.9

function result list, 5.1

function, runtime.Stack, 5.9

function, SearchIssues, 4.5

function, sexpr.Marshal, 12.4

function, sexpr.readList, 12.6

function, sexpr.Unmarshal, 12.6

function signature, 5.1

function, sort.Float64s, 7.6

function, sort.Ints, 7.6

function, sort.IntsAreSorted, 7.6

function, sort.Reverse, 7.6

function, sort.Strings, 4.3, 5.6, 7.6

function, Sprint, 12.1

function, sqlQuote, 7.13, 7.13

function, strconv.Atoi, 1.7, 3.5.5

function, strconv.FormatInt, 3.5.5

function, strconv.Itoa, 3.5.5

function, strconv.ParseInt, 3.5.5

function, strconv.ParseUint, 3.5.5

function, strings.Contains, 3.5.3

function, strings.HasPrefix, 3.5.3

function, strings.HasSuffix, 3.5.3

function, strings.Index, 10.6

function, strings.Join, 1.2, 1.3

function, strings.Map, 5.5

function, strings.NewReader, 10.6

function, strings.NewReplacer, 10.6

function, strings.Split, 1.3

function, strings.ToLower, 3.5.4

function, strings.ToUpper, 3.5.4

function, template.Must, 4.6

function, template.New, 4.6

function, Test, 11.1

function, time.After, 8.7

function, time.AfterFunc, 6.4

function, time.Now, 8.2

function, time.Parse, 8.2

function, time.Since, 4.6

function, time.Tick, 8.7, 8.7

function, title, 5.8, 5.8

function type, 5.1, 5.1

function, unicode.IsDigit, 3.5.4

function, unicode.IsLetter, 3.5.4

function, unicode.IsLower, 3.5.4

function, unicode.IsSpace, 4.2.2

function, unicode.IsUpper, 3.5.4

function, unsafe.AlignOf, 13.1

function, unsafe.Offsetof, 13.1

function, unsafe.Sizeof, 13.1

function, url.QueryEscape, 4.5

function, utf8.DecodeRuneInString, 3.5.3

function, utf8.RuneCountInString, 3.5.3

function value, 5.5

function, variadic, 5.7, 7.1

function, visit, 5.2

function, WaitForServer, 5.4.1

function, walkDir, 8.8

function zero value, 5.5




G

garbage collection, Preface, Preface, 1.2, 2.3.4, 8.4.2, 13, 13.2

garbage collector, moving, 13.2

GCD algorithm, 2.4.1

gcd function, 2.4.1

geometry example package, 6.1

geometry.Point.Distance method, 6.1

getter method, 6.6

GIF animation, 1.4

github example, 4.5, 4.5

GitHub issue tracker, 4.5

Go Blog, Preface, 11.5

go build, 1.1, 10.4, 10.7.3, 10.7.3

go doc, 10.7.4

go doc tool, 1.8

go env, 10.7.1

go get, Preface, 1.1, 10.7.2, 10.7.2

go help, 10.7

go install, 10.7.3

Go issue, 4.5, 4.5, 13.2

go list, 10.7.6, 11.2.4

go list -f flag, 11.2.4

Go Playground, Preface, 11.6

go -race flag, 9.6

go run, 1.1, 10.7.3

go statement, 1.6, 8.1

go test, 11, 11.1, 11.1, 11.2

go test -race flag, 9.7

go test -run flag, 11.2

go test -v flag, 11.2

go tool, 1.1, 2.6.1, 2.6.2, 10.7

go tool -bench flag, 11.4

go tool -benchmem flag, 11.4

go tool cover, 11.3, 11.3, 11.3

go tool -covermode flag, 11.3

go tool -coverprofile flag, 11.3

go tool -cpuprofile flag, 11.5

go tool -nodecount flag, 11.5

go tool pprof, 11.5

go tool -text flag, 11.5

go tool -web flag, 11.5

GOARCH environment variable, 10.7.1, 10.7.3

godoc -analysis flag, 7.3

godoc tool, Preface, 1.8, 10.7.4, 11.6

gofmt tool, 1.1, 1.2, 2.6.1, 10.4

goimports tool, 1.1, 2.6.1, 10.4

golang.org/x/net/html package, 5.2

golint tool, 10.7.2

GOMAXPROCS environment variable, 9.8.3, 11.4

GOOS environment variable, 10.7.1, 10.7.3

GOPATH environment variable, Preface, 10.7.1, 10.7.3

gopl.io repository, Preface

GOROOT environment variable, 10.7.1

goroutine, 1.6, 8.1, 8.4.4, 8.5

goroutine, closer, 8.5, 8.8

goroutine identity, 9.8.4

goroutine leak, 8.4.4, 8.5, 8.7

goroutine, monitor, 9.1, 9.7

goroutine multiplexing, 9.8.2

goroutine vs. OS thread, 9.8

goto statement, 1.8

graph example, 4.3

GraphViz, 11.5

Griesemer, Robert, Preface

growth, stack, 5.2, 9.8.1, 13.2

guarding mutex, 9.2




H

half-open interval, 1.2

handler function, 1.7, 1.7, 5.10, 7.7, 7.7, 7.7, 12.7

“happens before” relation, 8.4.1, 9.1, 9.1, 9.7

“has a” relationship, 6.3

hash table, 1.3, 4.3

Haskell programming language, Preface

heap allocation, 2.3.4

heap profile, 11.5

heap variable, 2.3.4

helloworld substring diagram, 3.5.3

helloworld example, 1.1, 1.1

hexadecimal escape, 3.5.1

hexadecimal literal, 3.1

hidden pointer, 13.2

Hoare, Tony, Preface

hole, struct, 13.1

HTML anchor element, 5.2

HTML escape, 4.6

HTML injection attack, 4.6

HTML metacharacter, 4.6

HTML parser, 5.2

html.Parse function, 5.2, 5.3

html/template package, 4.6, 4.6

http example, 7.7, 7.7, 7.7, 7.7

http example package, 7.7

HTTP GET request, 1.7, 5.3, 9.7, 12.7

HTTP POST request, 12.7

HTTP request, cancellation of, 8.9

HTTP request multiplexer, 7.7

(*http.Client).Do method, 8.9

http.DefaultClient variable, 8.9

http.DefaultServeMux function, 7.7

http.Error function, 7.7

http.Get function, 1.5, 1.6

http.Handle function, 7.7

http.HandleFunc function, 1.7, 1.7, 7.7

http.Handler interface, 7.7, 7.7

http.HandlerFunc type, 7.7, 7.9

http.ListenAndServe function, 1.7, 7.7

http.NewRequest function, 8.9

http.Request type, 1.7, 8.9

(*http.Request).ParseForm method, 1.7, 12.7

http.ResponseWriter type, 1.7, 1.7, 7.7, 7.7

http.ServeMux function, 7.7

hypot function, 5.1




I

identifier _, blank, 1.2, 2.4.1, 4.3, 5.1, 5.3, 10.5

identifier, qualified, 2.6, 2.6.1

identity, goroutine, 9.8.4

IEEE 754 standard, 3.2, 3.2

if, initialization statement in, 1.7, 7.10

if-else scope, 2.7

if-else statement, 1.3, 1.7, 2.7

imag built-in function, 3.3

image manipulation, 5.2

image package, 3.3, 10.5

image/color package, 1.4

image.Decode function, 10.5

image/png package, 10.5

image.RegisterFormat function, 10.5

imaginary literal, 3.3

immutability, 9.1

immutability, string, 3.5, 3.5.4

implementation with slice, stack, 4.2.2, 7.14

implicit &, 6.2, 6.5

implicit assignment, 2.4.2

implicit conversion, 3.6.2

implicit dereference, 6.2

import, blank, 10.5

import declaration, 1.1, 2.2, 2.6.1, 10.2, 10.4, 13.4

import path, 10.2, 10.2

import path domain name, 10.2

import, renaming, 10.4

incr function, 2.3.2

increment statement ++, 1.2, 2.4, 4.3

index operation, string, 3.5

indirection operator *, 1.8, 2.3.2

infinite loop, 1.2, 5.1, 8.4.2

information hiding, 6.6, 10.1

init function, 2.6.2, 2.7

initialization, lazy, 9.5

initialization, package, 2.6.2

initialization statement in if, 1.7, 7.10

initialization statement in switch, 1.8

initializer list, 2.3

injection attack, HTML, 4.6

injection attack, SQL, 7.13

in-place slice techniques, 4.2.2

insertion sort algorithm, 4.4

int type, 3.1

integer literal, 3.1

integer overflow, 3.1, 4.5

integer, signed, 3.1, 3.1

integer, unsigned, 3.1, 3.1

integration test, 11.2.4

interface assignability, 7.3

interface comparison, 7.5

interface dynamic type, 7.5

interface embedding, 7.2

interface, error built-in, 7.8, 7.8

interface, flag.Value, 7.4, 7.4

interface, fmt.Stringer, 7.4, 7.12

interface, http.Handler, 7.7, 7.7

interface, io.Closer, 7.2

interface, io.Reader, 7.2

interface, io.Writer, 1.4, 1.7, 7.1, 7.2, 7.5.1, 7.12, 7.12, 11.2.2

interface, JSON, 4.5

interface method call, 7.5

interface, nil, 7.5

interface pitfall, 7.5.1

interface, ReadWriteCloser, 7.2

interface, ReadWriter, 7.2

interface satisfaction, 7, 7.3

interface, sort.Interface, 7.6

interface{} type, 5.7

interface type, 7.1, 7.2

interface{} type, 7.3, 12.2, 12.2

interface type assertion, 7.12, 7.12

interface type, empty, 7.3

interface value, 7.5

interface with nil pointer, 7.5.1

interface zero value, 7.5

interfaces as contracts, 7.1

internal package, 10.7.5

intset example, 6.5, 6.5

intsToString function, 3.5.4

invariants, 6.2, 6.6, 6.6, 9.2, 10.1, 11.2.3, 12.9

io package, 7.2

io.Closer interface, 7.2

io.Copy function, 1.5, 1.6

io.Discard stream, 1.7

io.Discard variable, 1.6

io.EOF variable, 5.4.2

io/ioutil package, 1.5, 5.8

io.Reader interface, 7.2

iota constant generator, Preface, 3.6.1

ioutil.ReadAll function, 1.5, 9.7

ioutil.ReadDir function, 8.8

ioutil.ReadFile function, 1.3, 5.8

io.Writer interface, 1.4, 1.7, 7.1, 7.2, 7.5.1, 7.12, 7.12, 11.2.2

io.WriteString function, 7.12

“is a” relationship, 6.3, 7.3

issue, Go, 4.5, 4.5, 13.2

issue tracker, GitHub, 4.5

issues example, 4.5

issueshtml example, 4.6

issuesreport example, 4.6

iteration order, map, 4.3

iteration variable, capturing, 5.6.1

itob function, 3.4




J

Java programming language, Preface

JavaScript Object Notation (JSON), 4.5, 12.4

JavaScript programming language, Preface, 4.5

jpeg example, 10.5

JSON interface, 4.5

JSON interface, Open Movie Database, 4.5

JSON interface, xkcd, 4.5

JSON, marshaling, 4.5

JSON, unmarshaling, 4.5

json.Decoder type, 4.5

json.Encoder type, 4.5

json.Marshal function, 4.5

json.MarshalIndent function, 4.5

json.NewDecoder function, 4.5

json.NewEncoder function, 4.5

json.Unmarshal function, 4.5, 4.6




K

keyword, type, 7.13

keywords, table of, 2.1

Knuth, Donald, 11.5




L

label scope, 2.7

label, statement, 2.7

labeled break statement, 8.8

labeled continue statement, 8.8

labeled statement, 2.7





layout, memory, 13, 13.1, 13.1

lazy initialization, 9.5

leak, goroutine, 8.4.4, 8.5, 8.7

left shift operator <<, 3.1

len built-in function, 1.2, 3.1, 3.5, 3.5, 4.1, 4.2, 8.4.4

lexical block, 2.7, 5.1, 5.6, 5.6.1, 7.13

lexical closure, 5.6

lifetime, variable, 2.3.4, 2.7, 5.6

links example package, 5.6

links.Extract function, 5.6

Lisp programming language, 12.4

Lissajous algorithm, 1.4

lissajous example, 1.4, 1.7, 2.3.4

Lissajous figure, 1.4

list, initializer, 2.3

literal, array, 4.1, 4.1, 4.2

literal, composite, 1.4

literal, function, 1.7, 5.6, 8.4.1

literal, hexadecimal, 3.1

literal, imaginary, 3.3

literal, integer, 3.1

literal, map, 4.3

literal, octal, 3.1

literal, raw string, 3.5.1

literal, rune, 3.1

literal, slice, 2.4.2, 4.2

literal, string, 3.5.1

literal, struct, 1.4, 4.4.1, 4.4.3

local block, 2.7

local variable, 2.2, 5.6.1

local variable, address of, 2.3.2, 2.3.4

local variable scope, 5.6

locating packages, 10.7.1

lock contention, 9.3, 9.7

lock, exclusive, 9.2, 9.3, 9.5

lock, mutex, 4.4, 9.2, 9.2, 11.5

lock, non-reentrant, 9.2

lock, readers, 9.3

lock, shared, 9.3

lock, writer, 9.3

log package, 2.7, 5.4.1, 6.6

log.Fatalf function, 2.7, 5.4.1

lookup m[key], map, 4.3

lookup, ok value from map, 4.3

loop, infinite, 1.2, 5.1, 8.4.2

loop, range, 1.2, 1.3

loop variable, capturing, 5.6.1, 8.5, 8.6

loop variable scope, 5.6.1, 8.5

loop, while, 1.2




M

main function, 1.1, 11.2.2

main, package, 1.1, 10.3, 11.2.2

make built-in function, 1.3, 1.6, 4.2, 4.3, 8.4

make channel, 1.6, 8.4

make map, 1.3, 1.6, 4.3

make slice, 4.2, 11.4

mandelbrot example, 3.3

Mandelbrot figure, 3.3

Mandelbrot set, 3.3

map as set, 4.3, 7.9

map comparison, 4.3

map element, nonexistent, 4.3, 4.3

map iteration order, 4.3

map literal, 4.3

map lookup m[key], 4.3

map lookup, ok value from, 4.3

map, make, 1.3, 1.6, 4.3

map, nil, 4.3

map, range over, 4.3

map type, 1.3, 4.3

map with slice key, 4.3

map zero value, 4.3

marshaling JSON, 4.5

math package, 1.4, 3.2

math/big package, 3.3

math/cmplx package, 3.3

math.Hypot function, 6.1

math.Inf function, 3.2

math.IsInf function, 3.2

math.IsNaN function, 3.2

math.NaN function, 3.2

math/rand package, 10.3, 11.2.1

memo example, 9.7, 9.7, 9.7, 9.7, 9.7, 9.7

memo example package, 9.7

memoization, 9.7

memory allocation, 2.3.4, 2.3.4, 3.5.4, 4.2.1, 6.6, 7.12, 11.4

memory layout, 13, 13.1, 13.1

metacharacter, HTML, 4.6

method, (*bufio.Reader).ReadRune, 4.3, 4.3

method, (*bufio.Scanner).Err, 4.3

method, (*bufio.Scanner).Scan, 1.3

method, (*bufio.Scanner).Split, 4.3

method, (*bytes.Buffer).Grow, 6.6

method, (*bytes.Buffer).WriteByte, 3.5.4

method, (*bytes.Buffer).WriteRune, 3.5.4

method, (*bytes.Buffer).WriteString, 3.5.4

method call, interface, 7.5

method chaining, 4.6

method declaration, 2.5, 6.1

method, error.Error, 7.8

method, Expr.Check, 7.9

method expression, 6.4

method, Expr.Eval, 7.9

method, geometry.Point.Distance, 6.1

method, getter, 6.6

method, (*http.Client).Do, 8.9

method, (*http.Request).ParseForm, 1.7, 12.7

method name, 6.1

method, net.Conn.Close, 8.2

method, net.Listener.Accept, 8.2

method, (*os.File).Write, 7.5

method, path.Distance, 6.1

method promotion, 6.3

method receiver name, 6.1

method receiver parameter, 6.1

method receiver type, 6.1

method, reflect.Type.Field, 12.7

method, reflect.Value.Addr, 12.5

method, reflect.Value.CanAddr, 12.5

method, reflect.Value.Interface, 12.2, 12.5

method, reflect.Value.Kind, 12.2

method selector, 6.1

method, setter, 6.6

method, String, 2.5, 6.5, 12.1

method, (*sync.Mutex).Lock, 1.7, 5.8, 9.2

method, (*sync.Mutex).Unlock, 1.7, 5.8, 9.2

method, (*sync.Once).Do, 9.5

method, (*sync.RWMutex).RLock, 9.3

method, (*sync.RWMutex).RUnlock, 9.3

method, (*sync.WaitGroup).Add, 8.5

method, (*sync.WaitGroup).Done, 8.5

method, template.Funcs, 4.6

method, template.Parse, 4.6

method, (*testing.T).Errorf, 7.9, 11.2, 11.2

method, (*testing.T).Fatal, 11.2

method, time.Time.Format, 8.2

method value, 6.4

method, (*xml.Decoder).Token, 7.14

methods example, 12.8

methods of a type, displaying, 12.8

Microsoft Windows file name, 3.5.4

missing function body, 5.1

m[key], map lookup, 4.3

mobile platforms, 5.2

Modula-2 programming language, Preface

modularity, 10.1

monitor, 9.2, 9.7

monitor goroutine, 9.1, 9.7

movie example, 4.5, 4.5

moving garbage collector, 13.2

multimap, 6.2.1, 7.7

multiple-value assignment, 2.4.1

multiplexer, HTTP request, 7.7

multiplexing, event, 8.7

multiplexing, goroutine, 9.8.2

multithreading, shared-memory, 8, 9

multi-valued function, 1.3, 2.3, 2.4.1, 4.3, 5.3, 5.3

mustCopy function, 8.2

mutex, 5.8, 6.3, 8.10, 9.5

mutex, guarding, 9.2

mutex lock, 4.4, 9.2, 9.2, 11.5

mutex, read/write, 9.3, 9.3

mutual exclusion, 9.1, 9.2, 9.4

MySQL database driver, 10.2




N

name, method, 6.1

name, method receiver, 6.1

name, package, 2.1, 2.6.1

name, parameter, 5.1

name space, 2.6, 6.1, 10.1

named result, 5.1, 5.3

named result zero value, 5.1, 5.3

named type, 1.8, 2.5, 2.5, 4.4.3, 6.1

naming convention, 2.1, 6.6, 7.2, 10.6

naming, package, 10.6

NaN (not a number), 3.2, 4.3

narrowing conversion, 2.5, 3.1

negation operator !, 3.4

net package, 8.2

netcat example, 8.2, 8.3, 8.4.1

net.Conn type, 8.2

net.Conn.Close method, 8.2

net.Dial function, 8.2

netflag example, 3.6.1

net/http package, 1.5, 7.7

net.Listen function, 8.2

net.Listener type, 8.2

net.Listener.Accept method, 8.2

net/smtp package, 11.2.3

net/url package, 6.2.1

networking, 5.2, 8.2

new built-in function, 2.3.3

new, redefining, 2.3.3

nil channel, 8.7, 8.8

nil function, 5.5

nil interface, 7.5

nil map, 4.3

nil pointer, 2.3.2

nil pointer, interface with, 7.5.1

nil receiver, 6.2.1, 7.5.1

nil slice, 4.2

non-blocking cache, 9.7

non-blocking cache, concurrent, 9.7

non-blocking channel receive, 8.7

non-blocking select, 8.7

nonempty example, 4.2.2

nonexistent map element, 4.3, 4.3

non-reentrant lock, 9.2

non-standard package, 5.2

number, floating-point, 3.2

number zero value, 1.2, 2.3

numeric conversion, 3.6.2

numeric precision, 3.1, 3.6.2

numeric type, 3.1




O

Oberon programming language, Preface

object, 6.1

object-oriented programming (OOP), 6, 6.6

octal escape, 3.5.1

octal literal, 3.1

ok value, 2.4.1

ok value from channel receive, 8.4.2

ok value from function call, 5.4

ok value from map lookup, 4.3

ok value from type assertion, 7.10

omitempty field tag, 4.5

Open Movie Database JSON interface, 4.5

operation, atomic, 9.2

operation, conversion, 2.5, 3.1, 3.1, 3.1, 3.4, 3.5.3, 3.6.2, 3.6.2, 7.1, 7.6, 7.7, 7.12, 8.4.3, 13, 13.2

operator &, address-of, 1.8, 2.3.2, 2.3.2, 2.3.2, 4.3, 6.2, 6.5

operator &^, AND-NOT, 3.1

operator &^, bit-clear, 3.1

operator ^, bitwise complement, 3.1

operator |, bitwise OR, 6.5, 6.5

operator ==, comparison, 2.5, 3.4

operator ^, exclusive OR, 3.1

operator *, indirection, 1.8, 2.3.2

operator <<, left shift, 3.1

operator !, negation, 3.4

operator %, remainder, 3.1, 6.5

operator >>, right shift, 3.1

operator &&, short-circuit AND, 3.4

operator ||, short-circuit OR, 3.4

operator -, unary, 3.1

operator += , -= , etc., assignment, 1.2

operator +, string concatenation, 1.2, 3.5

operator +, unary, 3.1

operator associativity, 3.1

operator precedence, 3.1, 3.4

operator s[i:j], slice, 4.2, 4.2

operator s[i:j], substring, 3.5, 4.2

operators, assignment, 2.4, 3.1

operators, comparison, 2.5, 4.3

operators, table of binary, 3.1

operators, table of bitwise, 3.1

operators, table of comparison, 3.1

optimization, 9.2, 11.4, 11.5

optimization, premature, 11.5

OR operator ||, short-circuit, 3.4

order of declarations, 2.7

order, struct field, 4.4, 13.1

organization, workspace, 10.7.1

os package, 1.2, 7.11

OS thread vs. goroutine, 9.8

os.Args variable, 1.2

os.Close function, 1.3

os.Exit function, 1.5, 2.3.2, 2.7

*os.File type, 1.3, 1.3, 7.1, 7.3, 7.5.1, 12.3

os.FileInfo type, 8.8

(*os.File).Write method, 7.5

os.Getwd function, 2.7

os.IsExist function, 7.11

os.IsNotExist function, 7.11

os.IsPermission function, 7.11

os.LinkError type, 7.11

os.Open function, 1.3

os.PathError type, 7.11

os.Stat function, 8.8

outline example, 5.2, 5.5

overflow, integer, 3.1, 4.5

overflow, stack, 5.2




P

package API, 10.1, 10.7.4, 11.2.3, 12.3, 12.9

package back-door, 11.2.4

package, bank example, 9.1, 9.1, 9.2

package block, 2.7

package, bufio, 1.3

package, bytes, 3.5.4, 3.5.4

package, bzip example, 13.4

package, compress/bzip2, 13.4

package, crypto/sha256, 4.1

package, database/sql, 7.13, 10.5

package declaration, 1.1, 2.2, 2.6, 10.3

package documentation, 10.7.4

package, encoding/json, 4.5

package, encoding/xml, 4.5, 7.14

package, errors, 7.8

package, external test, 10.3, 11.2.4

package, flag, 2.3.2, 7.4

package, fmt, 1.1

package, format example, 12.2

package, geometry example, 6.1

package, golang.org/x/net/html, 5.2

package, html/template, 4.6, 4.6

package, http example, 7.7

package, image, 3.3, 10.5

package, image/color, 1.4

package, image/png, 10.5

package initialization, 2.6.2

package, internal, 10.7.5

package, io, 7.2

package, io/ioutil, 1.5, 5.8

package, links example, 5.6

package, log, 2.7, 5.4.1, 6.6

package main, 1.1, 10.3, 11.2.2

package, math, 1.4, 3.2

package, math/big, 3.3

package, math/cmplx, 3.3

package, math/rand, 10.3, 11.2.1

package, memo example, 9.7

package name, 2.1, 2.6.1

package naming, 10.6

package, net, 8.2

package, net/http, 1.5, 7.7

package, net/smtp, 11.2.3

package, net/url, 6.2.1

package, non-standard, 5.2

package, os, 1.2, 7.11

package, params example, 12.7

package, path, 3.5.4

package, path/filepath, 3.5.4

package, reflect, 12.2

package, regexp, 5.9

package, runtime, 5.9

package, sort, 4.3, 7.6, 7.6

package, storage example, 11.2.3, 11.2.3

package, strconv, 1.7, 3.5.4, 3.5.5

package, strings, 1.2, 3.5.4, 3.5.4, 10.6

package, sync, 8.5, 9.2

package, syscall, 7.8, 7.11

package, tempconv example, 2.6

package, testing, 10.3, 11.2

package, text/scanner, 12.6

package, text/tabwriter, 7.6

package, text/template, 4.6, 10.7.6

package, thumbnail example, 8.5

package, time, 1.6, 3.6.1, 7.5

package, unicode, 3.5.4

package, unicode/utf8, 3.5.3

package, unsafe, 13

package-level declaration, 2.2

packages, building, 10.7.3

packages, downloading, 10.7.2

packages, locating, 10.7.1

packages, querying, 10.7.6

palindrome, 7.6

palindrome example, 11.2, 11.2, 11.2.1

panic, 3.5, 5.10, 8.9

panic built-in function, 5.9, 5.9

paradoxical race, 9.4

parallel composition, 8.3

parallel, embarrassingly, 8.5

parallelism, 8

parameter, ..., 4.2.1, 5.7, 5.7, 7.1

parameter, function, 5.1

parameter, method receiver, 6.1

parameter name, 5.1

parameter passing, 5.1

parameter, unused, 5.1

params example, 12.7

params example package, 12.7

params.Unpack function, 12.7

parentheses, 1.2, 1.2, 1.3, 3.1, 3.4, 5.1, 5.8, 6.2, 10.4, 12.3, 12.6

Parse example, 5.10

parser, HTML, 5.2

Pascal programming language, Preface

path, ..., 10.7.2, 10.7.6

path package, 3.5.4

path.Distance method, 6.1

path/filepath package, 3.5.4

Pike, Rob, Preface, Preface, Preface, 3.5.3, 4.5

pipeline, 8.4.2

pipeline diagram, 8.4.2

pipeline example, 8.4.2, 8.4.2, 8.4.3

pitfall, interface, 7.5.1

pitfall, scope, 5.6.1

platforms, mobile, 5.2

Playground, Go, Preface, 11.6

playlist example, 7.6

png.Encode function, 3.3

pointer, 1.8, 2.3.2, 2.3.3

pointer aliasing, 2.3.2

pointer argument, 2.3.2, 4.1

pointer equality, 2.3.2

pointer, hidden, 13.2

pointer, nil, 2.3.2

pointer receiver, 6.2, 6.5

pointer to struct, 4.4, 4.4.1

pointer zero value, 2.3.2

polling channel, 8.7

polymorphism, ad hoc, 7.13

polymorphism, subtype, 7.13

PopCount function, 2.6.2

Portable Network Graphics (PNG), 3.3

POSIX file name, 3.5.4

POSIX standard, Preface, 3.1, 3.5.4, 7.8

precedence, operator, 3.1, 3.4

precision, floating-point, 3.2, 3.2, 3.3, 3.6.2

precision, numeric, 3.1, 3.6.2

precision of constants, 3.6.2

predeclared names, table of, 2.1

premature abstraction, 7.15, 11.2.5, 11.2.5

premature optimization, 11.5

Printf %%, 1.3

Printf verbs, table of, 1.3

Printf %b, 1.3, 3.1, 3.5.5

Printf %c, 1.3, 3.1

Printf %d, 1.3, 3.1

Printf %e, 1.3, 3.2

Printf %f, 1.3, 3.2

Printf %g, 1.3, 3.2

Printf %[n], 3.1

Printf %o, 1.3, 3.1

Printf %q, 1.3, 3.1, 4.3

Printf %s, 1.3

Printf %*s, 5.5, 5.5

Printf %T, 1.3

Printf %t, 1.3

Printf %T, 3.6.2

Printf %t, 4.1

Printf %T, 4.1, 7.5, 12.2

Printf %v, 1.3, 1.3

Printf %#v, 4.4.3, 7.11

Printf %x, 1.3, 3.1

Printf %#x, 3.1

Printf % x, 3.5.3

Printf %x, 4.1

production code, 11

profile, blocking, 11.5

profile, CPU, 11.5

profile, heap, 11.5

profiling, 11.5

programming language, Alef, Preface

programming language, APL, Preface

programming language, C, Preface, Preface, 1.1, 1.2, 3.1, 9.1, 13.4

programming language, C++, Preface, Preface, 13.4

programming language, Haskell, Preface

programming language, Java, Preface

programming language, JavaScript, Preface, 4.5

programming language, Lisp, 12.4

programming language, Modula-2, Preface

programming language, Oberon, Preface

programming language, Pascal, Preface

programming language, Python, Preface, 7.7

programming language, Ruby, Preface, 7.7

programming language, Scheme, Preface

programming language, Squeak, Newsqueak, Preface

promotion, method, 6.3

protocol buffers, 4.5

Python programming language, Preface, 7.7




Q

qualified identifier, 2.6, 2.6.1

querying packages, 10.7.6

quote character, ', 3.1




R

race condition, 1.7, 9.1, 9.1, 9.1

race detector, 9.6, 9.7

race, paradoxical, 9.4

randomized testing, 11.2.1

range over channel, 8.4.2

range over map, 4.3

range over string, 3.5.3, 4.2.1

range loop, 1.2, 1.3

{{range}} template action, 4.6

raw string literal, 3.5.1

reachability, 2.3.4

read, stale, 9.4

readers lock, 9.3

read/write mutex, 9.3, 9.3

ReadWriteCloser interface, 7.2

ReadWriter interface, 7.2

real built-in function, 3.3

receive <-ch, channel, 1.6, 8.4, 8.4.4

receive expression, 8.4

receive, non-blocking channel, 8.7

receive, ok value from channel, 8.4.2

receive-only channel type <-chan T, 8.4.3

receiver name, method, 6.1

receiver, nil, 6.2.1, 7.5.1

receiver parameter, method, 6.1

receiver, pointer, 6.2, 6.5

receiver type, method, 6.1

recover built-in function, 5.10

recursion, 5.2, 5.2, 8.8, 12.3, 12.4, 12.6, 13.3

recursive anonymous function, 5.6

recursive data structure, 4.4, 4.4, 4.5

recursive type, 2.7

redefining new, 2.3.3

reference, call by, 4.1

reference identity, 4.2

reference type, 1.3, 1.3, 4.3, 5.1

reflect package, 12.2

reflection, 12, 12.9, 13.3

reflect.StructTag type, 12.7

reflect.Type type, 12.2

reflect.Type.Field method, 12.7

reflect.TypeOf function, 12.2

reflect.Value type, 12.2, 12.5

reflect.Value zero value, 12.2

reflect.Value.Addr method, 12.5

reflect.Value.CanAddr method, 12.5

reflect.Value.Interface method, 12.2, 12.5

reflect.Value.Kind method, 12.2

reflect.ValueOf function, 12.2, 12.2, 12.3

reflect.Zero function, 12.6

regexp package, 5.9

regexp.Compile function, 5.9

regexp.MustCompile function, 5.9

regular expression, 3.5.1, 5.9, 5.9, 11.2, 11.4

relation, “happens before”, 8.4.1, 9.1, 9.1, 9.7

relationship, “has a”, 6.3

relationship, “is a”, 6.3, 7.3

remainder operator %, 3.1, 6.5

renaming import, 10.4

rendezvous, 8.4.4

replacement character , Unicode, 3.5.3, 4.3

repository, gopl.io, Preface

request, HTTP GET, 1.7, 5.3, 9.7, 12.7

request, HTTP POST, 12.7

request multiplexer, HTTP, 7.7

result list, function, 5.1

result, named, 5.1, 5.3

return, bare, 5.3

return statement, 2.2, 5.1, 5.3

rev example, 4.2

reverb example, 8.3, 8.3

right shift operator >>, 3.1

Ruby programming language, Preface, 7.7

rune literal, 3.1

rune slice to string conversion, 3.5.3

rune to string conversion, 3.5.3

rune type, 3.1, 3.5.2

runtime API, 11.5

runtime package, 5.9

runtime scheduler, 9.8.2

runtime.Stack function, 5.9




S

satisfaction, interface, 7, 7.3

Scalable Vector Graphics (SVG), 3.2

scheduler, runtime, 9.8.2

Scheme programming language, Preface

scope, declaration, 2.7, 5.6

scope, for, 2.7

scope, if-else, 2.7

scope, label, 2.7

scope, local variable, 5.6

scope, loop variable, 5.6.1, 8.5

scope pitfall, 5.6.1

scope, short variable declaration, 1.7, 2.7

scope, switch, 2.7

search algorithm, breadth-first, 5.6, 8.6

search algorithm, depth-first, 5.6

SearchIssues function, 4.5

select statement, empty , 8.7

select case, 8.7

select, default case in, 8.7

select, non-blocking, 8.7

select statement, 8.7, 8.7

select{} statement, 8.7

selective recovery, 5.10

selector, field, 6.1

selector, method, 6.1

semaphore, binary, 9.2

semaphore, counting, 8.6

semicolon, 1.1, 1.2

send ch<-, channel, 1.6, 8.4, 8.4.4

send statement, 8.4

send-only channel type chan<- T, 8.4.3

separate compilation, 10.1

sequence diagram, thumbnail, 8.5

sequential consistency, 9.4, 9.5

serial confinement, 9.1

server, chat, 8.10

server, concurrent clock, 8.2

server, concurrent echo, 8.3

server example, 1.7, 1.7, 1.7

set, map as, 4.3, 7.9

setter method, 6.6

sexpr example, 12.4

S-expression decode example, 12.6

S-expression decoding, 12.6

S-expression encoding, 12.4, 12.4

sexpr.Marshal function, 12.4

sexpr.readList function, 12.6

sexpr.Unmarshal function, 12.6

sha256 example, 4.1

SHA256 message digest, 4.1

shadowing declaration, 2.7, 2.7, 7.10, 7.13

shared lock, 9.3

shared variables, 9

shared variables, concurrency with, 9

shared-memory multithreading, 8, 9

shift operator <<, left, 3.1

shift operator >>, right, 3.1

short variable declaration, 1.2, 1.2, 2.3.1, 2.3.1

short variable declaration scope, 1.7, 2.7

short variable declaration statement, 1.2

short-circuit AND operator &&, 3.4

short-circuit evaluation, 3.4

short-circuit OR operator ||, 3.4

signature, function, 5.1

signed integer, 3.1, 3.1

s[i:j], slice operator, 4.2, 4.2

s[i:j], substring operator, 3.5, 4.2

simple statement, 1.2, 1.7

Sizeof table, 13.1

sleep example, 7.4

slice, 1.2

slice argument, 4.2

slice capacity, 4.2, 4.2.1

slice capacity growth diagram, 4.2.1

slice comparison, 4.2

slice, extending a, 4.2

slice key, map with, 4.3

slice literal, 2.4.2, 4.2

slice, make, 4.2, 11.4

slice, nil, 4.2

slice of months diagram, 4.2

slice operator s[i:j], 4.2, 4.2

slice rotation algorithm, 4.2

slice techniques, in-place, 4.2.2

slice type, 4.2

slice used as stack, 5.2

slice, zero length, 4.2

slice zero value, 3.5.4, 4.2

SMTP client, 11.2.3

socket, TCP, 8.2

socket, UDP, 8.2

socket, Unix domain, 8.2

sort algorithm, topological, 5.6

sort package, 4.3, 7.6, 7.6

sort.Float64s function, 7.6

sort.Interface interface, 7.6

sort.Ints function, 7.6

sort.IntsAreSorted function, 7.6

sort.IntSlice type, 7.6

sort.Reverse function, 7.6

sort.Strings function, 4.3, 5.6, 7.6

spinner example, 8.1

Sprint function, 12.1

SQL API, 7.13

SQL injection attack, 7.13

sqlQuote function, 7.13, 7.13

squares example, 5.6

Squeak, Newsqueak programming language, Preface

stack allocation, 2.3.4

stack, fixed-size, 5.2

stack growth, 5.2, 9.8.1, 13.2

stack implementation with slice, 4.2.2, 7.14

stack overflow, 5.2

stack, slice used as, 5.2

stack trace, 5.9, 8.9

stack variable, 2.3.4

stack, variable-size, 5.2

stale read, 9.4

standard, IEEE 754, 3.2, 3.2

standard, POSIX, Preface, 3.1, 3.5.4, 7.8

standard, Unicode, 1.1, 2.1, 3.1, 3.5.1, 3.5.2, 3.5.3, 3.5.3, 4.3

statement --, decrement, 1.2, 2.4

statement ++, increment, 1.2, 2.4, 4.3

statement, assignment, 1.2, 1.2, 2.4, 3.1, 4.3, 7.1

statement, break, 1.8, 2.7

statement, continue, 1.8, 2.7

statement coverage, 11.3, 11.3

statement, defer, 5.8, 5.9, 9.2

statement, fallthrough, 1.8, 7.13

statement, for, 1.2

statement, go, 1.6, 8.1

statement, goto, 1.8

statement, if-else, 1.3, 1.7, 2.7

statement label, 2.7

statement, labeled, 2.7

statement, return, 2.2, 5.1, 5.3

statement, select, 8.7, 8.7

statement, select{}, 8.7

statement, send, 8.4

statement, short variable declaration, 1.2

statement, simple, 1.2, 1.7

statement, switch, 1.8, 2.7

statement, tagless switch, 1.8

statement, type switch, 7.13, 7.13, 7.14, 12.1

statement, unreachable, 5.1

storage example package, 11.2.3, 11.2.3

Strangelove, Dr., 12.3

strategies, error-handling, 5.4.1, 5.10, 11.2.2, 11.2.5

strconv package, 1.7, 3.5.4, 3.5.5

strconv.Atoi function, 1.7, 3.5.5

strconv.FormatInt function, 3.5.5

strconv.Itoa function, 3.5.5

strconv.ParseInt function, 3.5.5

strconv.ParseUint function, 3.5.5

stream, io.Discard, 1.7

string comparison, 3.5

string concatenation operator +, 1.2, 3.5

string conversion, 3.5.4

string immutability, 3.5, 3.5.4

string index operation, 3.5

string literal, 3.5.1

string literal, raw, 3.5.1

String method, 2.5, 6.5, 12.1

string, range over, 3.5.3, 4.2.1

string sharing diagram, 3.5

string test, 3.5.4

string to byte slice conversion, 2.5, 3.5.4

string to rune slice conversion, 3.5.3, 4.2.1

string zero value, 1.2, 1.2, 2.3

strings package, 1.2, 3.5.4, 3.5.4, 10.6

strings.Contains function, 3.5.3

strings.HasPrefix function, 3.5.3

strings.HasSuffix function, 3.5.3

strings.Index function, 10.6

strings.Join function, 1.2, 1.3

strings.Map function, 5.5

strings.NewReader function, 10.6

strings.NewReplacer function, 10.6

strings.Reader type, 10.6

strings.Replacer type, 10.6

strings.Split function, 1.3

strings.ToLower function, 3.5.4

strings.ToUpper function, 3.5.4

struct comparison, 4.4.2

struct declaration, 4.4

struct embedding, 4.4.3, 6.3

struct, Employee, 4.4

struct, empty, 4.4

struct field, 1.4, 4.4

struct field, anonymous, 4.4.3, 4.4.3, 4.4.3, 6.3

struct field, embedded, 6.3

struct field, export of, 4.4, 4.4.3, 4.5, 4.5, 6.6

struct field order, 4.4, 13.1

struct field tag, 4.5, 12.7

struct hole, 13.1

struct hole diagram, 13.1

struct literal, 1.4, 4.4.1, 4.4.3

struct literal, address of, 4.4.1

struct, pointer to, 4.4, 4.4.1

struct type, 1.4, 1.8, 4.4

struct{} type, 8.4.1, 8.6, 8.8

struct type, unnamed, 6.3

struct zero value, 4.4

substitutability, 7.7

substring operator s[i:j], 3.5, 4.2

subtype polymorphism, 7.13

sum example, 5.7

surface example, 3.2, 7.9

surface figure, three-D, 3.2, 7.9

SVG, 3.2

SWIG, 13.4

Swiss army knife, 10.7

switch, case in type , 7.13

switch, context, 9.8.2

switch, default case in, 1.8

switch, default case in type , 7.13

switch, initialization statement in, 1.8

switch scope, 2.7

switch statement, 1.8, 2.7

switch statement, tagless, 1.8

switch statement, type, 7.13, 7.13, 7.14, 12.1

sync package, 8.5, 9.2

synchronous channel, 8.4.1

sync.Mutex type, 9.2, 9.5

(*sync.Mutex).Lock method, 1.7, 5.8, 9.2

(*sync.Mutex).Unlock method, 1.7, 5.8, 9.2

sync.Once type, 9.5

(*sync.Once).Do method, 9.5

sync.RWMutex type, 9.3, 9.5

(*sync.RWMutex).RLock method, 9.3

(*sync.RWMutex).RUnlock method, 9.3

sync.WaitGroup type, 8.5, 8.8, 9.7

(*sync.WaitGroup).Add method, 8.5

(*sync.WaitGroup).Done method, 8.5

syscall package, 7.8, 7.11

syscall.Errno type, 7.8, 7.8

system call API, 7.8




T

table of binary operators, 3.1

table of bitwise operators, 3.1

table of comparison operators, 3.1

table of escape sequences, 3.5.1

table of keywords, 2.1

table of predeclared names, 2.1

table of Printf verbs, 1.3

table of UTF-8 encodings, 3.5.3

table, Sizeof, 13.1

table-driven testing, 7.9, 11.2, 11.3

tag, struct field, 4.5, 12.7

tagless switch statement, 1.8

tags, build, 10.7.3

TCP socket, 8.2

techniques, in-place slice, 4.2.2

tempconv example, 2.5, 7.4, 10.6

tempconv example package, 2.6

temperature conversion example, 2.2

tempflag example, 7.4

template, | in, 4.6

template action, {{range}}, 4.6

template API, 4.6

template, dot . in, 4.6

template.Funcs method, 4.6

template.HTML type, 4.6

template.Must function, 4.6

template.New function, 4.6

template.Parse method, 4.6

test assertion, 11.2

test, black-box, 11.2.3

test, brittle, 11.2.6

test, character, 3.5.4

test coverage, 11.3

test dependency, cyclic, 11.2.4

test, echo, 11.2.2

test failure message, 11.2

Test function, 11.1

test, integration, 11.2.4

test of word example, 11.2

test package, external, 10.3, 11.2.4

test, string, 3.5.4

test, white-box, 11.2.3

_test.go file, 10.3, 11.1, 11.2

testing a command, 11.2.2

testing package, 10.3, 11.2

testing, randomized, 11.2.1

testing, table-driven, 7.9, 11.2, 11.3

testing.B type, 11.4

testing.T type, 11.2

(*testing.T).Errorf method, 7.9, 11.2, 11.2

(*testing.T).Fatal method, 11.2

tests, writing effective, 11.2.5, 11.2.6

text/scanner package, 12.6

text/tabwriter package, 7.6

text/template package, 4.6, 10.7.6

Thompson, Ken, Preface, 3.5.3

thread, 8.1, 9.8.1

thread-local storage, 9.8.4

three-D surface figure, 3.2, 7.9

thumbnail example, 8.5, 8.5, 8.5

thumbnail example package, 8.5

thumbnail sequence diagram, 8.5

time package, 1.6, 3.6.1, 7.5

time.After function, 8.7

time.AfterFunc function, 6.4

time.Duration type, 3.6, 7.4

time.Minute constant, 3.6

time.Now function, 8.2

time.Parse function, 8.2

time.Second constant, 6.4

time.Since function, 4.6

time.Tick function, 8.7, 8.7

time.Time type, 4.6

time.Time.Format method, 8.2

title example, 5.10

title function, 5.8, 5.8

token-based decoder API, 7.14, 7.14, 12.6

token-based XML decoding, 7.14

tool, cgo, 13.4, 13.4

tool, go, 1.1, 2.6.1, 2.6.2, 10.7

tool, go doc, 1.8

tool, godoc, Preface, 1.8, 10.7.4, 11.6

tool, gofmt, 1.1, 1.2, 2.6.1, 10.4

tool, goimports, 1.1, 2.6.1, 10.4

tool, golint, 10.7.2

topological sort algorithm, 5.6

topoSort example, 5.6

trace example, 5.8

trace, stack, 5.9, 8.9

tree, binary, 4.4

treesort example, 4.4

true boolean constant, 3.4

truncation, floating-point, 2.5, 3.1

tuple assignment, 2.3.1, 2.4.1

type <-chan T, receive-only channel, 8.4.3

type chan<- T, send-only channel, 8.4.3

type switch, case in, 7.13

type switch, default case in, 7.13

type, abstract, 1.8, 7.1

type, aggregate, 4, 4.4

type, array, 4.1

type assertion, 7.10, 7.13

type assertion, interface, 7.12, 7.12

type assertion, ok value from, 7.10

type, bool, 3.4

type, bufio.Scanner, 1.3

type, byte, 3.1

type, bytes.Buffer, 3.5.4, 6.6, 7.1, 7.5.1

type, Celsius, 2.5

type, chan, 8.4

type, channel, 1.6

type, complex, 3.3

type, composite, Preface, 1.4, 4

type composition, Preface, 4.4.3, 6.3, 7.6

type, concrete, 1.8, 7.1, 7.13, 7.14

type declaration, 2.5

type, displaying methods of a, 12.8

type, empty interface, 7.3

type, error built-in, 1.3, 5.4, 5.9, 7.8

type, Fahrenheit, 2.5

type, function, 5.1, 5.1

type, http.HandlerFunc, 7.7, 7.9

type, http.Request, 1.7, 8.9

type, http.ResponseWriter, 1.7, 1.7, 7.7, 7.7

type, int, 3.1

type, interface{}, 5.7

type, interface, 7.1, 7.2

type, interface{}, 7.3, 12.2, 12.2

type, interface dynamic, 7.5

type, json.Decoder, 4.5

type, json.Encoder, 4.5

type keyword, 7.13

type, map, 1.3, 4.3

type, method receiver, 6.1

type mismatch, 3.1

type, named, 1.8, 2.5, 2.5, 4.4.3, 6.1

type, net.Conn, 8.2

type, net.Listener, 8.2

type, numeric, 3.1

type, *os.File, 1.3, 1.3, 7.1, 7.3, 7.5.1, 12.3

type, os.FileInfo, 8.8

type, os.LinkError, 7.11

type, os.PathError, 7.11

type, recursive, 2.7

type, reference, 1.3, 1.3, 4.3, 5.1

type, reflect.StructTag, 12.7

type, reflect.Type, 12.2

type, reflect.Value, 12.2, 12.5

type, rune, 3.1, 3.5.2

type, slice, 4.2

type, sort.IntSlice, 7.6

type, strings.Reader, 10.6

type, strings.Replacer, 10.6

type, struct, 1.4, 1.8, 4.4

type, struct{}, 8.4.1, 8.6, 8.8

type switch statement, 7.13, 7.13, 7.14, 12.1

type, sync.Mutex, 9.2, 9.5

type, sync.Once, 9.5

type, sync.RWMutex, 9.3, 9.5

type, sync.WaitGroup, 8.5, 8.8, 9.7

type, syscall.Errno, 7.8, 7.8

type, template.HTML, 4.6

type, testing.B, 11.4

type, testing.T, 11.2

type, time.Duration, 3.6, 7.4

type, time.Time, 4.6

type, uint, 3.1

type, uintptr, 3.1, 13.1, 13.2

type, underlying, 2.5

type, unidirectional channel, 8.4.3, 8.4.3, 8.4.3

type, unnamed struct, 6.3

type, unsafe.Pointer, 13.2

type, url.URL, 7.7

types, untyped constant, 3.6.2




U

UDP socket, 8.2

uint type, 3.1

uintptr type, 3.1, 13.1, 13.2

unary operator -, 3.1

unary operator +, 3.1

unbuffered channel, 8.4, 8.4.1

undefined behavior, 9.1

underlying array, 4.2, 4.2, 4.2.1, 7.6

underlying type, 2.5

Unicode code point, 3.5.2

Unicode escape, 3.5.3, 4.5

unicode package, 3.5.4

Unicode replacement character , 3.5.3, 4.3

Unicode standard, 1.1, 2.1, 3.1, 3.5.1, 3.5.2, 3.5.3, 3.5.3, 4.3

unicode.IsDigit function, 3.5.4

unicode.IsLetter function, 3.5.4

unicode.IsLower function, 3.5.4

unicode.IsSpace function, 4.2.2

unicode.IsUpper function, 3.5.4

unicode/utf8 package, 3.5.3

unidirectional channel type, 8.4.3, 8.4.3, 8.4.3

union, discriminated, 7.13, 7.13, 7.14

universe block, 2.7

Unix domain socket, 8.2

unmarshaling JSON, 4.5

unnamed struct type, 6.3

unnamed variable, 2.3.3, 4.2

unreachable statement, 5.1

unsafe package, 13

unsafe.AlignOf function, 13.1

unsafe.Offsetof function, 13.1

unsafe.Pointer conversion, 13.2

unsafe.Pointer type, 13.2

unsafe.Pointer zero value, 13.2

unsafe.Sizeof function, 13.1

unsigned integer, 3.1, 3.1

untyped constant types, 3.6.2

unused parameter, 5.1

URL, 5.2

URL escape, 4.5

url.QueryEscape function, 4.5

url.URL type, 7.7

urlvalues example, 6.2.1

UTF-8, 3.5.1, 3.5.3, 4.3

UTF-8 encodings, table of, 3.5.3

utf8.DecodeRuneInString function, 3.5.3

utf8.RuneCountInString function, 3.5.3

utf8.UTFMax value, 4.3




V

value, addressable, 2.3.2

value, call by, 4.1, 5.1, 6.2

value, function, 5.5

value, interface, 7.5

value, method, 6.4

value, utf8.UTFMax, 4.3

var declaration, 1.2, 2.3

variable confinement, 9.1

variable, heap, 2.3.4

variable, http.DefaultClient, 8.9

variable, io.Discard, 1.6

variable, io.EOF, 5.4.2

variable lifetime, 2.3.4, 2.7, 5.6

variable, local, 2.2, 5.6.1

variable, os.Args, 1.2

variable, stack, 2.3.4

variable, unnamed, 2.3.3, 4.2

variables, escaping, 2.3.4

variables, shared, 9

variable-size stack, 5.2

variadic function, 5.7, 7.1

vector, bit, 6.5

vendoring, 10.7.2

visibility, 2.1, 2.2, 2.6, 6.6, 10.7.5

visit function, 5.2




W

wait example, 5.4.1

WaitForServer function, 5.4.1

walkDir function, 8.8

web crawler, 5

web crawler, concurrent, 8.6

web framework, 7.7

while loop, 1.2

white-box test, 11.2.3

Wilkes, Maurice, 11

Wirth, Niklaus, Preface

word example, 11.2, 11.2, 11.2.1

word example, test of, 11.2

workspace organization, 10.7.1

writer lock, 9.3

writing effective tests, 11.2.5, 11.2.6




X

xkcd JSON interface, 4.5

XML decoding, 7.14

XML (Extensible Markup Language), 4.5

(*xml.Decoder).Token method, 7.14

xmlselect example, 7.14




Y




Z

zero length slice, 4.2

zero value, array, 4.1

zero value, boolean, 2.3

zero value, channel, 8.4, 8.7

zero value, function, 5.5

zero value, interface, 7.5

zero value, map, 4.3

zero value, named result, 5.1, 5.3

zero value, number, 1.2, 2.3

zero value, pointer, 2.3.2

zero value, reflect.Value, 12.2

zero value, slice, 3.5.4, 4.2

zero value, string, 1.2, 1.2, 2.3

zero value, struct, 4.4

zero value, unsafe.Pointer, 13.2





Code Snippets


Many titles include programming code or configuration examples. To optimize the presentation of these elements, view the eBook in single-column, landscape mode and adjust the font size to the smallest setting. In addition to presenting code and configurations in the reflowable text format, we have included images of the code that mimic the presentation found in the print book; therefore, where the reflowable format may compromise the presentation of the code listing, you will see a “Click here to view code image” link. Click the link to view the print-fidelity code image. To return to the previous page viewed, click the Back button on your device or app.





