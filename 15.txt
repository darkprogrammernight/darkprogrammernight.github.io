Chapter 15. Other Cool Stuff in Vim





Chapters 10 through 14 covered powerful Vim features and techniques we think you should know about to make effective use of the editor. This chapter takes a lighter look at Vim. It’s a catch-all for some of the features that didn’t fit into previous topics, ideas about editing and the Vim philosophy, and some fun things about Vim (not that the earlier chapters weren’t fun!).





Editing Binary Files





Officially, Vim, like vi, is a text editor. But in pinch, Vim also lets you edit files containing data that is normally unreadable by humans.

Why would you ever want to edit a binary file? Aren’t binary files binary for a reason? Aren’t binary files typically generated by some application in a well-defined and specific format?





Warning


While we enjoy Vim’s binary editing feature, we do not present an in-depth discussion about potential serious issues to consider while editing binary files. For example, some binary files contain digital signatures or checksums to ensure file integrity. Editing these files risks damaging their integrity and could render them unusable. Therefore, do not consider this an endorsement of casual binary edits.



It’s true that binary files are typically created by a computerized or analog process and are not intended to be edited manually. For example, digital cameras often store pictures in JPEG format, a compressed binary format for digital pictures. These are binary, but they have well-defined sections or blocks where standard information is stored (that is, they do if they’re implemented according to specification). Digital pictures in JPEG format store picture meta-information (time of picture, resolution, camera settings, date, etc.) in reserved blocks separate from the compressed digital picture data. A practical application might use Vim’s binary file editing feature to edit a directory of JPEG pictures to change all of the year fields in the “created” block to correct the picture’s “date of creation” field.

Figure 15-1 shows an editing session on a JPEG file. Notice how the cursor is positioned over the date field. You can directly edit information about this picture by changing these fields.





Figure 15-1. Editing a binary JPEG file



For power users familiar with a particular binary format, Vim can be extremely handy for making changes directly that might otherwise require tedious, repetitive access with other tools.

There are two main ways to edit binary files. You can set the binary option from the Vim command line:

set binary

or start Vim with the -b option.

To facilitate binary editing and protect Vim from damaging the file’s integrity, Vim sets the following options accordingly:

The textwidth and wrapmargin options are set to 0. This stops Vim from inserting spurious newline sequences into the file.



The modeline and expandtab options are unset (nomodeline and noexpandtab). This stops Vim from expanding tabs to shiftwidth spaces, and prevents it from interpreting commands in a modeline, which potentially would set options that introduce unexpected and unwanted side effects.





Note


Be careful when moving from window to window, or buffer to buffer, when using binary mode. Vim uses entry and exit events to set and change options for switching buffers and windows, and you may confuse it into removing some of the protections just listed. We recommend a single-window, single-buffer session when editing binary files.





Digraphs: Non-ASCII Characters





Do you say that the Messiah is composed by George Frideric Händel, not George Frideric Handel? Do you think your résumé conveys a little more cachet than a resume? Use Vim’s digraphs to enter special characters.

Even English-language text files occasionally need a special character, especially when making references to a globalized world. Text files in languages other than English need scads of special characters.

Vim lets you enter special characters in a number of ways, and two of them are relatively straightforward and intuitive. Both rely on defining a digraph through a prefix (CTRL-K) or the use of the BS (Backspace) key between two keyboard characters. (The other methods are more suited to entering characters by their raw numerical values, specified as decimal, hexadecimal, or octal numbers. While powerful, these methods do not lend themselves to easy mnemonics for digraphs.)





Note


The term digraph traditionally describes a two-letter combination that represents a single phonetic sound, such as the ph in “digraph” or “phonetic.” Vim borrows the notion of “two-letter” combinations to describe its input mechanism for characters with special characteristics, typically accents or other markings such as the umlaut on ä. These special marks are properly called diacritics, or diacritical marks. In other words, Vim uses digraphs to create diacritics. Glad we could clear that up.



The first input method for diacritics is a three-character sequence consisting of CTRL-K, the base letter, and a punctuation character indicating the accent or mark to be added. For example, to create a c with a cedilla (ç), enter CTRL-Kc,. To create an a with a grave accent (à), enter CTRL-Ka!.

Greek letters can be created by a corresponding Latin letter followed by an asterisk (for instance, enter CTRL-Kp* for a lowercase π). Russian letters can be created by a corresponding Latin letter followed by an equals sign or, in a few places, a percent sign. Use CTRL-K?I (make sure to use a capital I) to enter an inverted question mark (¿) and CTRL-Kss to enter a German sharp S (ß).

To use Vim’s second method, set the digraph option:

set digraph

Now create special characters by typing the first character of the two-character combination, then a backspace character (BS), and then the punctuation that creates a mark. Thus, enter ç through cBS, and à through aBS!.

Setting the digraph option doesn’t preclude you from entering digraphs with the CTRL-K method. Consider using only the CTRL-K method if your typing is less than stellar. Otherwise, you may find yourself inadvertently entering digraphs more often than you want as you backspace and type corrections.

Use the :digraph command to show all the default sequences; more verbose descriptions can be obtained with :help digraph-table. Figure 15-2 shows a partial list from the digraph command.





Figure 15-2. Vim digraphs



In the display, each digraph is represented by three columns. The display is a bit jumbled because Vim jams as many three-column combinations on each line as the screen permits. For each of the groups, column one shows the digraph’s two-character combination, column two displays the digraph, and column three lists the decimal Unicode value for the digraph.

For your convenience, Table 15-1, lists the punctuation to use as the final character in the sequence to enter the most commonly needed accents and marks.

Table 15-1. How to enter accents and other marks

Mark

Character to enter as part of digraph



Acute accent (fiancé)

Apostrophe (')



Breve (publică)

Left parenthesis (



Caron (Dubček)

Less-than sign (<)



Cedilla (français)

Comma (,)



Circumflex or carot (português)

Greater-than sign (>)



Grave accent (voilà)

Exclamation point (!)



Macron (ātmā)

Hyphen (-)



Stroke (Søren)

Slash (/)



Tilde (señor)

Question mark (?)



Umlaut or diaeresis (Noël)

Colon (:)





Editing Files in Other Places





Thanks to seamless integration of network protocols, Vim lets you edit files on remote machines just as if they were local! If you simply specify a URL for a filename, Vim opens it in your window and writes your changes to it on the remote system (depending on your access rights). For instance, the following command edits a .vimrc file owned by user ehannah on the system mozart. The remote machine offers the SSH secure protocol on port 122 (this is a nonstandard port, providing additional security through obscurity):

$vim scp://ehannah@mozart:122//home/ehannah/.vimrc

Because we’re editing a file in ehannah’s home directory on the remote machine, we can shorten the URL by using a simple filename. It’s treated as a pathname relative to the user’s home directory on the remote system:

$vim scp://ehannah@mozart:122/.vimrc

Let’s take apart the URL so you can learn how to build URLs for your particular environment:

scp:

The first part, up to the colon, represents the transport protocol. In this example, the protocol is scp, a file copy protocol built on the Secure Shell (SSH) protocol. The following : is required.



//

This introduces host information, which for most transport protocols takes the form [user@]hostname[:port].



ehannah@

This is optional. For secure protocols such as scp, it specifies what user to log in as on the remote machine. When omitted, it defaults to your username on the local machine. When you are prompted for a password, you must enter the user’s password on the remote machine.



mozart

This is the remote machine’s symbolic name, and it can also be specified as a numeric address, e.g., 192.168.1.106.



:122

This is optional and specifies the port on which the protocol is provided. The colon separates the port number from the preceding hostname. All standard protocols use well-known ports, so this element of the URL can be omitted if the standard port is used. In this example, 122 in not the standard port for the scp protocol, and because the administrator of the mozart system has chosen to provide the service on 122, this specification is required.



//home/ehannah/.vimrc

This is the file on the remote machine we want to edit. We start with two slashes because we’re specifying an absolute path. A relative path or simple filename requires only a single slash to separate it from the preceding hostname. A relative path is relative to the home directory of the user that you logged in as. So, in the example a relative path would be relative to ehannah’s home directory, e.g., /home/ehannah.





Here is a partial list of the supported protocols:

ftp: and sftp: (regular FTP and secure FTP)



scp: (secure remote copy over SSH)



http: (file transfer using standard browser protocol)



dav: (a relatively new but popular proposed open standard for web transfer)



rcp: (remote copy)





What we’ve described so far is enough to allow remote editing, but the process may not be as transparent as editing a file locally. That is, because of the intervening requirement to move data from remote hosts, you may be prompted for passwords to do your work. This can become tedious if you are used to periodically writing your file to disk while editing, as each of the “writes” is interrupted to prompt you to enter a password to complete the transaction.

All of the transport protocols in the preceding list allow you to configure the service to allow password-free access, but the details vary. Use the service’s documentation for specific protocol details and configurations.





Navigating and Changing Directories





If you’ve used Vim a lot, you may have accidentally discovered that you can view a directory and move through it using keystrokes similar to those used with files.

Let’s consider a directory containing many .c files, ex-050325 (this happens to be the directory containing the compilable source for the original vi editor). Edit ex-050325 with:

$vim ex-050325

Figure 15-3 is a partial screenshot of something similar to what you might see.





Figure 15-3. Vim “editing” the ex-050325 directory



Vim displays three types of information: introductory comments (preceded by equals signs), directories (displayed with trailing slashes), and files. Each directory or file is on its own line.

There are many ways to use this feature, but with little effort you can be immediately and intuitively productive with standard Vim motion commands (e.g., w to move to the next word, j or the down arrow to jump down one line) and by clicking the mouse over entries. Some particular features of directory mode include:

When the cursor is positioned over a directory name, move to that directory by pressing the ENTER key.



If the cursor is over a filename, pressing ENTER edits that file.





Tip


If you want to keep the directory window around for further work in that directory, edit the file under the cursor by typing o, and Vim will split the window, editing the file in the newly created window. (This is also true for moving to another directory when the cursor is over a directory name; Vim splits the window and “edits” the directory to which you moved in the new window.)



You can delete and rename files and directories. Rename a file or directory by typing capital R. Probably a little counterintuitively, Vim creates a command-line prompt with which you perform the rename. It should look something like Figure 15-4.

To complete the rename, edit the second command-line argument.

Deleting a file works similarly. Simply position the cursor over the filename you want to delete and type capital D. Vim prompts you with a verification dialog to delete the file. As with the rename function, Vim prompts for verification in the command-line area of the screen.





Figure 15-4. Prompt for rename in “edit directory”



One really nice advantage of editing directories is quick access to files through Vim’s search function. For example, suppose you want to edit the file expreserve.c in the ex-050325 directory described earlier. To quickly navigate to and edit this file, you can search for part or all of the filename:

/expreserve.c

and with the cursor over that filename, press ENTER or o.





Note


When you read the online help for directory editing, you will see that Vim describes it as part of the entire suite of editing files with network protocols, which was described in the previous section. We have made directory editing its own topic in this chapter because it is useful, and it could get lost in the large volume of detail about network protocol editing.





Backups with Vim





Vim helps protect you from unintentionally losing data by letting you make a backup of the files you edit. For an edit session that has gone terribly wrong, this can be useful because you can recover your previous file.

Backups are controlled by the settings of two options: backup and writebackup. Where and how backups are created are controlled by four other options: backupskip, backupcopy, backupdir, and backupext.

If both the backup and writebackup options are off (i.e., nobackup and nowritebackup), Vim makes no backup files for your edit sessions. If backup is on, Vim deletes any old backups and creates a backup for the current file. If backup is off and writebackup is on, Vim creates a backup file for the duration of the edit session and deletes the backup afterward.

The backupdir is a comma-separated list of directories in which Vim creates backup files. For example, if you want backups to always be created in your system’s temporary directory, set backupdir to "C:\TEMP" for Windows or "/tmp" for Unix and Linux.





Tip


If you’d like to always create a backup of your file in the current directory, you can specify “.” (a dot) as your backup directory. Or you could try to create a backup in a hidden subdirectory first if it exists, and then in the current directory if the hidden subdirectory doesn’t exist. Do this by defining backupdir’s value to be something such as "./.mybackups,." (the single dot at the end denotes the file’s current directory). This is a flexible option that supports many strategies for defining backup locations.



If you want to make backups for your edit sessions but not for all files, use the backupskip option to define a comma-separated list of patterns. Vim will not make a backup of any file matching one of the patterns. For example, you may never want to back up any files edited in the /tmp or /var/tmp directories. Prevent Vim from doing so by setting backupskip to "/tmp/*,/var/tmp/*".

By default, Vim creates your backup with the same filename as the original and the suffix ~ (a tilde). This is a fairly safe suffix, because filenames ending in that character are rare. Change the suffix to your preference with the backupext option. For example, if you want your backups to have the suffix .bu, set backupext to the string ".bu".

Finally, the backupcopy option defines how a backup copy is created. We recommend setting this option to "auto" to let Vim make a calculated choice of the best method for the backup.





HTML Your Text





Have you ever needed to present your code or text to a group? Have you ever tried to do a code review but were using someone else’s Vim configuration and couldn’t figure it out? Consider converting your text or code to HTML and viewing it from a browser.

Vim provides three methods to create an HTML version of your text. They all create a new buffer with the same name as the original file and the suffix .html Vim splits the current session window and displays the HTML version of the file in the new window:

gvim “Convert to HTML”

This is the friendliest method, and is built into the gvim graphical editor (described in Chapter 13). Open the Syntax menu in gvim and select “Convert to HTML.”



2html.vim script

This is the underlying script invoked by the “Convert to HTML” menu option described in the previous item. Invoke it through the command:

:runtime!syntax/2html.vim

It doesn’t accept a range; it converts the whole buffer.



TOhtml command

This is more flexible than the 2html.vim script, because you can specify an exact range of lines you want to convert. For instance, to convert lines 25 through 44 of a buffer, enter:

:25,44TOhtml





One advantage of using gvim for HTML conversion is that the GUI lets it accurately detect colors and create correct corresponding HTML directives. These methods still work in a non-GUI context, but the results are less assured to be accurate and may not be very useful.





Note


It’s up to you to manage the newly created file. Vim does not save it for you; it merely creates a buffer. We recommend providing a management policy to save and synchronize HTML versions of your text files. For example, you could create some autocommands to trigger the creation and saving of your HTML files.



The saved HTML file can be viewed in any web browser. Some people may not be familiar with ways to open files on the local system in their browsers. It’s quite easy, though: virtually all browsers offer an Open File menu option in the File menu and display a file selection dialog to let you navigate to the folder containing the HTML file. If you plan on using this feature on a regular basis, we recommend building up a collection of bookmarks for all of your files.





What’s the Difference?





Changes between different versions of a file are often subtle, and a tool that lets you view precise differences at a glance could save hours of work. Vim integrates the well known Unix diff command into a very sophisticated visualization interface invoked through its vimdiff command.

There are two equivalent ways to invoke this feature: as a standalone command and as an option to Vim:

$vimdiff old_file new_file $vim -d old_file new_file

Typically, the first file to be compared is an old version of a file, and the second is a newer version, but that is by convention only. Indeed, it’s possible to make a case for reversing the order.

Figure 15-5 shows an example of vimdiff output. Because of limited real estate, we’ve squeezed the width and turned off Vim’s wrap option to allow illustration of the differences.





Figure 15-5. vimdiff results



Though the figure does not convey the full impact of the visual content (particularly because colors are reduced to gray), it shows some key characteristic behaviors:

On line 4, you can see a dark block on the left line that isn’t on the right line. This is a highlighted word indicating a difference between the two lines. Similarly, on line 32, the righthand line contains a highlighted word that is not on the left.



On line 11 of both sides, Vim has created a 15-line fold. These 15 lines in both files are identical, so Vim folds them to maximize useful “diff” information on the screen.



Lines 41–42 on the left are highlighted, whereas in the corresponding positions on the right, strings of hyphens (-) indicate that the lines are missing. The line numbering differs from this point on, because the right side has two lines fewer, but corresponding lines in the two files still line up horizontally.





The vimdiff feature comes with all Unix-like Vim installations because the diff command is a Unix standard. Non-Unix Vim installations should come with Vim’s own version of diff. Vim allows drop-in replacements of diff commands as long as they create standard diff output.

The diffexpr variable defines the replacement expression for the default vimdiff behavior and is typically implemented as a script that operates on the following variables:

v:fname_in

The first input file to be compared



v:fname_new

The second file to be compared



v:fname_out

A file that captures the diff output





Undoing Undos





Beyond the convenience of undoing an arbitrary number of edits, Vim offers an interesting twist called branching undos.

To use this feature, first decide how much control you want over undoing edits. Use the undolevels option to define the number of undoable changes you can make in an edit session. The default is 1,000, which is probably more than enough for most users. If you want vi compatibility, set undolevels to zero:

:set undolevels=0

In vi, the undo command u is basically a toggle between the file’s current state and its most recent change. The first undo reverts to the state before the last change. The next undo redoes the undone change. Vim behaves quite differently, and therefore the commands are implemented differently.

Instead of toggling the most recent change, repeated invocations of Vim’s undo rolls back the state of the file through the most recent changes, in order, for as many changes as defined by the undolevels option. Because the undo command u only moves backward, we need a command to roll forward and “redo” changes. Vim does this with the redo command, :redo, or the CTRL-R key. The CTRL-R key accepts a numeric prefix to redo several changes at once.

When rolling forward and backward through changes with the redo (CTRL-R) and undo (u) commands, Vim maintains a map of the file’s state and knows when the last possible undo has been performed. When all possible undos are done, Vim resets the file’s modified status, which allows quitting without the ! suffix. Although this is a modest benefit for general user interaction, it is more useful for behind-the-scenes scripting where the modified state of the file is important.

For most users, simply undoing and redoing changes is sufficient. But consider a more complex scenario. What if you make seven changes to a file, and undo three? So far, so good, nothing unusual to consider. But now, suppose that after undoing three out of seven changes, you then make a change different from the next forward change in Vim’s collection of changes? Vim defines that point in the change history as a branch from which different paths of changes occur. With that path you can now move back and forth chronologically, with the added twist that at a branch point you can move forward along any of the different paths of recorded changes.

For more complete descriptions of how to navigate changes as a tree, use Vim’s help command:

:help usr_32.txt





Now, Where Was I?





Most text editors start editing files at line 1, column 1. That is, each time the editor is started, the file is loaded and editing begins from line 1. If you edit a file many times, progressing through it, you would find it more convenient to begin an edit session where the last one ended. Vim lets you do just that.

There are two different methods to save edit session information for future uses: the viminfo option and the mksession command.





The viminfo Option





Vim uses the viminfo option to define what, how, and where to save edit session information. The option is a string with comma-delimited parameters that tell Vim how much information to save and where to save it. Some of viminfo’s suboptions are defined by the following:

<n

Tells Vim to save lines for each register, up to a maximum of n lines.





Tip


If you do not specify any value for this option, all lines are saved. While at first this may seem to be the normal desire, consider whether you commonly edit very large files and make large changes to those files. For example, if you commonly edit a 10,000-line file and delete all lines (possibly to pare it down from rapid growth caused by some external application) and then save it, all 10,000 lines get saved in the viminfo file for that entry. If you do this often for many files, the viminfo file will grow very large. You may then notice long delays when starting Vim, even for files not related to the large file, because Vim must process the viminfo file each time it starts up.

We recommend specifying some sane but useful limit. This author uses 50.





/n

The number of search pattern history items to be saved. If not specified, Vim uses the value in the history option.



:n

The maximum number of commands from the command-line history to save. If not specified, Vim uses the value in the history option.



'n

The maximum number of files for which Vim maintains information. If you define the viminfo option, this parameter is required.





Here is what Vim saves in the viminfo file:

Command-line history



Search string history



Input-line history



Registers



File marks (e.g., a mark created by mx is saved and can be moved to when re-editing the file by typing 'x)



Last search and substitute patterns



Buffer list



Global variables





This option is really handy for sustaining continuity across edit sessions. For example, if you edit a large file in which you are changing a pattern, the search pattern is remembered as well as where the cursor is positioned in the file. To continue searching in a new session, you need only type n to move to the next occurrence of the search pattern.





The mksession Command





Vim saves all edit information specific to a session with its mksession command. The sessionoptions option contains a comma-separated string specifying which components of a session to save. This way of saving edit session information is much more comprehensive but much more specific than viminfo. Saving session information this way is specific to all of the files, buffers, windows, etc. in the current edit session, and mksession saves the information so that the entire session can be reconstructed. All of the files being edited and all of the settings for all options, even window sizes, are saved so that reloading the information brings back an exact recreation of the session. Contrast this with viminfo, which only restores edit information on a per-file basis.

To save a session this way, enter:

:mksession [filename]

where filename specifies a file in which to save the session information. Vim creates a script file that, when executed later with the source command, reconstructs the session. (The default filename, if none was specified, is Session.vim.). So, if you save a session with the command:

:mksession mysession.vim

you could later reestablish the session with the command:

:source mysession.vim

Here is what you can save from a session, and the parameter in the sessionoptions option to save it:

blank

Empty windows



buffers

Hidden and unloaded buffers



curdir

The current directory



folds

Manually created folds, opened/closed folds, and local fold options





Note


It wouldn’t make any sense to save anything but manually created folds. Automatically created folds will be automatically recreated!





globals

Global variables, which start with an uppercase letter and contain at least one lowercase letter



help

The help window



localoptions

Options defined locally to a window



options

Options set by :set



resize

Size of the Vim window



sesdir

The directory in which the session file is located



slash

Backslashes in filenames replaced with forward slashes



tabpages

All tab pages





Note


If you do not specify this in the sessionoptions string, only the current tab session is saved as a standalone entity. This gives you the flexibility of defining sessions at either the tab level or globally across all tabs.





unix

Unix end-of-line format



winpos

Position of Vim window on the screen



winsize

Size of buffer windows on the screen





So, for example, if you want to save a session to retain all information for all buffers, all folds, global variables, all options, window size, and window position, you would define the sessionoptions option with:

:set sessionoptions=buffers,folds,globals,options,resize,winpos





What’s My Line (Size)?





Vim allows lines of virtually unlimited lengths. You can have them either wrap onto multiple screen lines, so you can see them all without horizontal scrolling, or you can display the beginning of each line on one screen line and scroll to the right to see hidden parts.

If you prefer one line of text per screen line, turn off the wrap option:

set nowrap

With nowrap, Vim displays as many characters as the screen width permits. Think of the screen as a view port or window through which the wide line is viewed. For example, a 100-character line contains 20 characters too many for a screen that is 80 columns wide. Depending on what character is displayed in the screen’s first column, Vim determines which characters in the 100-character line are not displayed. For example, if the screen’s first column is the line’s 5th character, characters 1–4 are to the left of the visible screen and therefore invisible, that is, not displayed. Characters 5–84 are visible in the screen, and the remaining characters from 85–100 are to the right of the screen and are also invisible.

Vim manages how the line is displayed as you move left and right through the long line. Vim shifts the line left and right a minimum of sidescroll characters. You can set its value as follows:

set sidescroll=n

where n is the number of columns to scroll. We recommend setting sidescroll to 1, because modern PCs easily provide the processing power necessary to smoothly shift the screen one column at a time. If your screen slows down and response times lag, you may need to bump the value to something higher to minimize the screen redraws.

The sidescroll value defines a minimum shift. As you probably expect, Vim shifts far enough to complete any motion commands. For example, typing w moves the cursor to the next word in the line. However, Vim’s treatment of the movement is a bit tricky. If the next word is partially visible (on the right), Vim moves to the first character of that word but does not shift the line. The next w command will shift the line to the left far enough to position the cursor over the first character of the next word, but only far enough to expose this first character.

You can control this behavior with the sidescrolloff option. sidescrolloff defines the minimum number of columns to maintain to the right and left of the cursor. So, for example, if you defined sidescrolloff to be 10, Vim maintains at least 10 characters of context as the cursor nears either side of the screen. Now when you move left and right on a line, your cursor will never get closer than (in this case) 10 columns from either side of the screen, as Vim shifts enough text into view to maintain that context. This is probably a better way to configure Vim in nowrap mode.

Vim provides convenient visual cues with the listchar option. listchar defines how to display characters when Vim’s list option is set. Vim also provides two settings in this option that control whether to use characters to indicate if there are more characters to the left or right of the visible screen for long lines. For example:

set listchars=extends:> set listchars+=precedes:<

tells Vim to display a < in column 1 if a long line contains more characters to the left of the visible screen, and a > in the last column to indicate there are more characters to the right of the visible screen. Figure 15-6 shows an example.





Figure 15-6. A long line in nowrap mode





In contrast, if you prefer to see a whole line without scrolling, tell Vim to wrap the lines with the wrap option:

set wrap

Now the line appears as in Figure 15-7.





Figure 15-7. A long line in wrap mode





Very long lines that can’t be entirely displayed on the screen are displayed with the single character @ in the first position, until the cursor and file are positioned in such a way that the line can be displayed completely. The line in Figure 15-7 appears as shown in Figure 15-8 when it is near the bottom of the screen.





Figure 15-8. Long line indicator





Abbreviations of Vim Commands and Options





There are so many commands and options in Vim that we recommend learning them by name first. Almost all commands and options (at least any that have more than a few characters) have some associated short form. These can save time, but be sure you know what you’re abbreviating! This author has had some embarrassing and unexpected results using short forms thought to be one thing that turned out to be something quite different.

As you become more experienced and develop your favorite subset of Vim commands and options, using some of the abbreviated forms for commands and options saves time. Vim typically tries for Unix-like abbreviations for options and allows for the shortest unique initial substring for commands’ abbreviations.

Some abbreviations for common commands include:

n next

prev previous

q quit

se set

w write



Some abbreviations for common options include:

ai autoindent

bg background

ff fileformat

ft filetype

ic ignorecase

li list

nu number

sc showcommand (notshowcase)

sm showmatch

sw shiftwidth

wm wrapmargin



Short forms for commands and options save time when you know your commands and options well. But for scripting and setting up sessions with commands in your .vimrc or .gvimrc files, you’re more likely to save time in the long run by sticking with full command and option names. Your configuration file and scripts are easier to read and debug when you use full names.





Note


Note that this is not the approach taken with the suite of Vim script files (syntax, autoindent, colorscheme, etc.) in the Vim distribution, though we take no issue with their approach. We just recommend, for ease of managing your own scripts, that you stay with full names.





A Few Quickies (Not Necessarily Vim-Specific)





We now offer several techniques—some of which are offered by basic vi as well as Vim—that are worth remembering and having handy:

A quick swap

A common typing error is to enter two characters in the wrong order. Position the cursor over the first wayward character and type xp (delete character, put character).



Another quick swap

Got two lines you’d rather swap? Position the cursor on the top line, and type ddp (delete line, put line after current line).



Quick help

Don’t forget about Vim’s built-in help. A quick tap on the F1 function key splits your screen and displays the introduction to the online help.



What was that great command I used?

In its simplest form, Vim lets you access recently executed commands by using the arrow keys in the command line. Moving up and down with the arrow keys, Vim displays recent commands, any one of which you may edit. Whether or not you edit a command from Vim’s history, you can execute the command by pressing the ENTER key.

You can get even more sophisticated by invoking Vim’s built-in command history editing. Do this by entering CTRL-F on the command line. A small “command” window opens up (with the default height of 7) in which you can navigate with normal Vim motion commands. You can search as if in a normal Vim buffer, and make changes.

In the command edit window, you can easily find a recent command, modify it if necessary, and execute it by pressing ENTER. You can write the buffer to a filename of your choice, to record the command history for future reference.



A bit of humor

Try entering the command:

:help sure

and read Vim’s reply.





More Resources





Here are two links for HTML renditions of Vim’s built-in help for the two most recent major Vim releases:

Vim 6.2

http://www.vim.org/htmldoc/help.html



Vim 7

http://vimdoc.sourceforge.net/htmldoc/usr_toc.html





Additionally, http://vimdoc.sourceforge.net/vimfaq.html is a Vim Frequently Asked Questions list. It doesn’t link questions to answers, but it is all on one page. We recommend scrolling down to the section with the answers and scanning from there.

The official Vim page used to host tips on Vim, but because of problems with spammers, the administrators moved the tips to a wiki where spam is more easily managed. That wiki is here: http://vim.wikia.com/wiki/Category:Integration.



























