This chapt er is a tour of the basic comp onents of Go. We hop e to provide enough infor mat ion
and examples to get you off the gro und and doing useful things as quickly as possible. The
examples here, and indeed in the whole book, are aimed at tasks that you mig ht have to do in
the real wor ld. In this chapt er we’ll try to give you a taste of the diversity of programs that one
mig ht write in Go, ranging fro m simple file pro cessing and a bit of graphics to con cur rent
Internet clients and ser vers. We cer tain ly won’t explain everything in the firs t ch apt er, but
studying such programs in a new langu age can be an effec tive way to get started.
Wh en you’re learning a new langu age, there’s a natural tendency to write code as you wou ld
have writt en it in a langu age you already know. Be aware of this bias as you learn Go and try
to avoid it. We’ve tried to illustrate and explain how to write good Go, so use the code here as
a guide when you’re writing your own.
1.1. Hello, World
We’ll start wit h the now-t radition al ‘‘hel lo, wor ld’’ example, which app ears at the beg inning of
The C Programmi n g Lang uage, publishe d in 1978. C is one of the most direc t influences on
Go, and ‘‘hel lo, wor ld’’ illustrates a number of central ideas.
gopl.io/ch1/helloworld
package main
import "fmt"
func main() {
fmt.Println("Hello,
}
BF ")
12
CHAPTER 1.
TUTORIAL
Go is a compi led langu age. The Go toolchain conv erts a source program and the things it
dep ends on int o inst ruc tions in the nat ive machine langu age of a computer. These tools are
accessed through a single command cal le d go that has a number of sub command s. The sim-
plest of these sub command s is run , which compi les the source code fro m on e or more source
files whose names end in .go , lin ks it wit h librar ies, then runs the resulting exe cut able file.
(We will use $ as the command pro mpt throughout the book.)
$ go run helloworld.go
No t surprisingly, this prints
Hello,
BF
Go nat ive ly handles Unico de, so it can pro cess text in all the wor ld’s langu ages.
If the program is more than a one-shot exp eriment, it’s likely that you wou ld want to compi le
it once and save the compi led result for later use. That is don e with go build :
$ go build helloworld.go
This cre ates an exe cut able binar y file cal le d helloworld that can be run any time wit hout fur-
ther pro cessing:
$ ./helloworld
Hello, BF
We have lab ele d each sig nificant example as a reminder that you can obt ain the code fro m the
book’s source code rep ository at gopl.io :
gopl.io/ch1/helloworld
If you run go get gopl.io/ch1/helloworld , it will fetch the source code and place it in the
corresponding direc tor y. There’s more about this topic in Sec tion 2.6 and Sec tion 10.7.
Let’s now tal k ab out the program its elf. Go code is organize d into packages, which are simi lar
to librar ies or modules in other langu ages. A package con sists of one or more .go source files
in a single direc tor y that define what the package does. Each source file beg ins wit h a package
de clarat ion, here package main , that states which package the file belon gs to, fol low ed by a list
of other packages that it imp orts, and then the declarat ions of the program that are store d in
that file.
The Go stand ard librar y has over 100 packages for common tasks like inp ut and out put,
sorting, and text manipu lat ion. For ins tance, the fmt package contains functions for printing
formatte d output and scanning inp ut. Println is one of the basic out put functions in fmt ; it
pr ints one or more values, sep arated by spaces, wit h a newline charac ter at the end so that the
values appear as a single line of out put.
Package main is speci al. It defines a stand alone exe cut able program, not a librar y. Wit hin
package main the func tion main is als o sp eci al—it’s where exe cut ion of the program beg ins.
Wh ate ver main do es is what the program does. Of course, main wi l l normal ly cal l up on func-
tion s in other packages to do much of the wor k, such as the function fmt.Println .SECTION 1.1. HELLO, WORLD
3
We must tel l the compi ler what packages are needed by this source file; that’s the role of the
import de clarat ion that fol lows the package de clarat ion. The ‘‘hel lo, wor ld’’ prog ram us es
on ly one function fro m on e ot her package, but most programs will imp ort more packages.
Yo u mu st imp ort exac tly the packages you need. A prog ram wi l l not compi le if there are
missing imp orts or if there are unnecessary ones. This str ict requirement pre vents references
to unu sed packages fro m acc umulat ing as programs evo l ve.
The import de clarat ions must fol low the package de clarat ion. After that, a program consists
of the declarat ions of functions, var iables, cons tants, and typ es (introduce d by the key words
func , var , const , and type ); for the most par t, the order of declarat ions does not matter. This
prog ram is about as short as possible since it declares only one function, which in tur n calls
on ly one other function. To save space, we will som etimes not show the package and import
de clarat ions when present ing examples, but the y are in the source file and must be there to
comp ile the code.
A function declarat ion con sists of the key word func , the name of the function, a parameter
list (empt y for main ), a result list (also emp ty here), and the body of the function—the state-
ments that define what it does—enclos ed in braces. We’ll take a clos er lo ok at functions in
Chapter 5.
Go does not require semicolons at the end s of statements or declarat ions, except where two or
more app ear on the same line. In effec t, newlines fol low ing cer tain tokens are converted int o
semicolons, so where newlines are place d matt ers to pro per parsing of Go code. For ins tance,
the opening brace { of the function must be on the same line as the end of the func de clara-
tion, not on a line by its elf, and in the expression x + y , a newline is per mitt ed after but not
before the + op erator.
Go takes a stron g st ance on code for matting . The gofmt to ol rewrites code int o the stand ard
format, and the go to ol’s fmt su bcommand app lies gofmt to all the files in the specified pack-
age, or the ones in the cur rent direc tor y by defau lt. All Go source files in the book have been
run through gofmt , and you should get into the habit of doing the same for your own code.
Decl aring a stand ard for mat by fiat eliminates a lot of point less deb ate about trivia and, more
importantly, enables a variet y of aut omated source code transfor mat ions that wou ld be
infeasible if arbit rar y formatting were allow ed.
Many text editors can be configured to run gofmt each time you save a file, so that your source
co de is always pro perly for matte d. A rel ate d to ol, goimports , addition ally manages the ins er-
tion and removal of imp ort declarat ions as needed. It is not par t of the stand ard distr ibution
but you can obt ain it wit h this command:
$ go get golang.org/x/tools/cmd/goimports
Fo r most users, the usu al way to dow nlo ad and bui ld packages, run their tests, show their doc-
umentation, and so on, is wit h the go to ol, which we’ll look at in Sec tion 10.7.4
CHAPTER 1.
TUTORIAL
1.2. Command-Line Arguments
Most programs pro cess som e input to pro duce som e output; that’s prett y much the definition
of computing . But how does a program get input dat a on which to operate? Som e prog rams
generate their own data, but more often, input com es fro m an exter nal source: a file, a net wor k
connec tion, the out put of another program, a user at a key board , command-line arguments,
or the like. The next few examples will dis cuss som e of these alt ernat ives, starting wit h com-
mand-line arguments.
The os package provides functions and other values for dealing wit h the operat ing system in a
pl atfor m-indep endent fashion. Command-line arguments are avai lable to a program in a
var iable named Args that is par t of the os package; thu s its name any where outside the os
package is os.Args .
The var iable os.Args is a sli ce of str ings. Slices are a fundament al not ion in Go, and we’ll tal k
a lot more about them soon. For now, thin k of a slice as a dynamic ally size d sequence s of
ar ray elements where indiv idu al elements can be accessed as s[i] and a contiguous subse-
quence as s[m:n] . The number of elements is given by len(s) . As in most other program-
ming langu ages, all indexing in Go uses half-open intervals that include the firs t index but
exclude the last, because it simplifies logic. For example, the slice s[m:n] , where 0 ≤ m ≤ n ≤
len(s) , contains n-m elements.
The firs t element of os.Args , os.Args[0] , is the name of the command its elf; the other ele-
ments are the arguments that were present ed to the program when it started exe cut ion. A
slice expression of the for m s[m:n] yields a slice that refers to elements m thro ugh n-1 , so the
elements we need for our next example are those in the slice os.Args[1:len(os.Args)] . If m
or n is omitt ed, it defau lts to 0 or len(s) resp ectively, so we can abbreviate the desired slice as
os.Args[1:] .
Here’s an imp lementation of the Unix echo command, which prints its command-line argu-
ments on a single line. It imp orts two packages, which are given as a parenthesize d list rat her
than as individu al import de clarat ions. Eit her for m is legal, but convent ion ally the list for m is
us ed. The order of imp orts doesn’t matter; the gofmt to ol sor ts the package names into
alph abetical order. (Wh en there are several versions of an example, we will often number
them so you can be sure of which one we’re tal king about.)
gopl.io/ch1/echo1
// Echo1 prints its command-line arguments.
package main
import (
"fmt"
"os"
)SECTION 1.2. COMMAND-LINE ARGUMENTS
5
func main() {
var s, sep string
for i := 1; i < len(os.Args); i++ {
s += sep + os.Args[i]
sep = " "
}
fmt.Println(s)
}
Comments beg in with // . All text fro m a // to the end of the line is comment ary for
prog rammers and is ignored by the compi ler. By convent ion, we des crib e each package in a
comment immediate ly pre ceding its package declarat ion; for a main package, this comment is
on e or more complete sentences that des crib e the program as a whole.
The var de clarat ion declares two var iables s and sep , of typ e string . A var iable can be ini-
tialize d as par t of its declarat ion. If it is not explicitly initialize d, it is imp licitly initialize d to
the zero value for its typ e, which is 0 for numer ic types and the emp ty str ing "" for str ings.
Thus in this example, the declarat ion imp licitly initializes s and sep to emp ty str ings. We’ll
have more to say about var iables and declarat ions in Chapt er 2.
Fo r numb ers, Go provides the usu al arithmetic and log ical operator s. When app lie d to
st rings, how ever, the + op erator concatenate s the values, so the expression
sep + os.Args[i]
repres ents the con catenat ion of the str ings sep and os.Args[i] . The statement we used in
the program,
s += sep + os.Args[i]
is an assig nment statement that conc atenates the old value of s with sep and os.Args[i] and
assig ns it back to s ; it is equivalent to
s = s + sep + os.Args[i]
The operator += is an assig nment operator. Each arithmetic and log ical operator like + or * has
a cor responding assig nment operator.
The echo prog ram could have print ed its out put in a loop one pie ce at a time, but this version
instead bui lds up a str ing by rep eatedly app ending new text to the end. The str ing s st arts life
empt y, that is, wit h value "" , and each trip through the loop adds som e text to it; after the firs t
it erat ion, a space is als o inserted so that when the loop is finishe d, there is one space bet ween
each argument. This is a quadrat ic process that cou ld be costly if the number of arguments is
large , but for echo , that’s unlikely. We’ll show a number of imp rov ed versions of echo in this
ch apt er and the next that will deal wit h any real inefficiency.
The loop index variable i is declare d in the firs t part of the for lo op. The := sy mbol is par t of
a sh ort var iab le declarati on, a statement that declares one or more var iables and gives them
appropriate typ es based on the initializer values; there’s more about this in the next chapt er.
The increment statement i++ adds 1 to i ; it’s equivalent to i += 1 which is in tur n equivalent
to i = i + 1 . There’s a cor responding decrement statement i-- that subtrac ts 1. Thes e are6
CHAPTER 1.
TUTORIAL
st atements, not expressions as the y are in most langu ages in the C fami ly, so j = i++ is illegal,
and the y are postfix only, so --i is not legal either.
The for lo op is the only loop statement in Go. It has a number of for ms, one of which is
illustrated here:
for initialization; condition; post {
// zero or more statements
}
Parent hes es are never used aro und the three components of a for lo op. The braces are
mand atory, how ever, and the opening brace must be on the same line as the post st atement.
The opt ion al initialization st atement is exe cut ed before the loop starts. If it is present, it
mu st be a simp le statement, that is, a short var iable decl arat ion, an increment or assig nment
st atement, or a function cal l. The condition is a boole an expression that is evaluate d at the
beginning of each iterat ion of the loop; if it evaluates to true , the statements control led by the
lo op are exe cut ed. The post st atement is exe cut ed after the body of the loop, then the con di-
tion is evaluate d again. The loop end s when the con dit ion becom es false.
Any of these par ts may be omitt ed. If there is no initialization and no post , the semi-
colons may also be omitt ed:
// a traditional "while" loop
for condition {
// ...
}
If the con dit ion is omitt ed ent ire ly in any of these for ms, for example in
// a traditional infinite loop
for {
// ...
}
the loop is infinite, thoug h lo ops of this for m may be ter minated in som e ot her way, like a
break or return st atement.
Anot her for m of the for lo op iterates over a ra nge of values fro m a dat a type like a st ring or a
slice. To illustrate, here’s a secon d version of echo :
gopl.io/ch1/echo2
// Echo2 prints its command-line arguments.
package main
import (
"fmt"
"os"
)SECTION 1.2. COMMAND-LINE ARGUMENTS
7
func main() {
s, sep := "", ""
for _, arg := range os.Args[1:] {
s += sep + arg
sep = " "
}
fmt.Println(s)
}
In each iterat ion of the loop, range produces a pair of values: the index and the value of the
element at that index. In this example, we don’t need the index, but the syntax of a range lo op
re quires that if we deal wit h the element, we must deal wit h the index too. One ide a would be
to assig n the index to an obv iou sly temporar y var iable like temp and ignore its value, but Go
do es not per mit unu sed local variables, so this wou ld result in a compi lat ion error.
The solut ion is to use the bl ank ident ifier, whose name is _ (t hat is, an underscore). The blank
identifier may be used whene ver synt ax requires a variable name but prog ram log ic do es not,
for ins tance to dis card an unwante d lo op index when we require only the element value. Most
Go programmers wou ld likely use range and _ to write the echo prog ram as abov e, since the
indexing over os.Args is imp licit, not explicit, and thu s easier to get rig ht.
This version of the program uses a short var iable decl arat ion to declare and initialize s and
sep , but we cou ld equ ally wel l have declare d the var iables sep arately. There are several ways
to declare a str ing var iable; these are all equivalent:
s := ""
var s string
var s = ""
var s string = ""
Why should you prefer one for m to another? The firs t form, a short var iable decl arat ion, is
the most compact, but it may be used only wit hin a function, not for package-le vel var iables.
The secon d form relies on defau lt initializat ion to the zero value for str ings, which is "" . The
third for m is rarely used except when declaring multiple var iables. The fourth for m is explicit
ab out the var iable’s typ e, which is redundant when it is the same as that of the initial value but
ne cessary in other cas es where the y are not of the same typ e. In prac tice, you should general ly
us e on e of the firs t two for ms, wit h explicit initializat ion to say that the initial value is
important and imp licit initializat ion to say that the initial value doesn’t matter.
As not ed above , each time aro und the loop, the str ing s gets comp letely new contents. The +=
st atement makes a new str ing by con catenat ing the old str ing , a space charac ter, and the next
argument, then assig ns the new str ing to s . The old cont ents of s are no lon g er in use, so the y
wi l l be garb age-collec ted in due course.
If the amount of dat a invo l ved is large , this cou ld be costly. A simpler and more efficient
solut ion wou ld be to use the Join func tion fro m the strings package:8
CHAPTER 1.
TUTORIAL
gopl.io/ch1/echo3
func main() {
fmt.Println(strings.Join(os.Args[1:], " "))
}
Final ly, if we don’t care about for mat but just want to see the values, perhaps for debug ging, we
can let Println format the results for us:
fmt.Println(os.Args[1:])
The out put of this statement is like what we wou ld get fro m strings.Join , but wit h sur-
ro unding brackets. Any slice may be print ed this way.
Exercis e 1.1: Mo dif y the echo prog ram to als o pr int os.Args[0] , the name of the command
that invo ked it.
Exercis e 1.2: Mo dif y the echo prog ram to print the index and value of each of its arguments,
on e per line.
Exercis e 1.3: Experiment to measure the dif ference in running time bet ween our pot ent ial ly
inefficient versions and the one that uses strings.Join . (Section 1.6 illustrates par t of the
time package, and Sec tion 11.4 shows how to write benchmark tests for systematic per-
formance evaluation.)
1.3. Finding Duplicate Lines
Prog rams for file copy ing , pr int ing , searching, sor ting, count ing , and the like all have a simi lar
st ruc ture: a loop over the inp ut, som e comp utation on each element, and generat ion of out put
on the fly or at the end. We’ll show three var iants of a program cal le d dup ; it is par tly ins pired
by the Unix uniq command, which looks for adj acent dup lic ate lines. The str uctures and
packages used are model s that can be easi ly adapt ed.
The firs t version of dup pr ints each line that app ears more than once in the stand ard inp ut,
preceded by its count. This program introduces the if st atement, the map data typ e, and the
bufio package.
gopl.io/ch1/dup1
// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main
import (
"bufio"
"fmt"
"os"
)SECTION 1.3. FINDING DUPLICATE LINES
9
func main() {
counts := make(map[string]int)
input := bufio.NewScanner(os.Stdin)
for input.Scan() {
counts[input.Text()]++
}
// NOTE: ignoring potential errors from input.Err()
for line, n := range counts {
if n > 1 {
fmt.Printf("%d\t%s\n", n, line)
}
}
}
As wit h for , parenthes es are never used aro und the con dit ion in an if st atement, but braces
are required for the body. There can be an opt ion al else part that is exe cut ed if the con dit ion
is false.
A map holds a set of key/value pairs and provides cons tant-t ime operat ions to store , retr ieve,
or test for an item in the set. The key may be of any typ e whos e values can comp are d with == ,
st rings being the most common example; the value may be of any typ e at all. In this example,
the keys are str ings and the values are int s. The bui lt-in function make creates a new emp ty
map; it has other uses too. Maps are dis cussed at lengt h in Sec tion 4.3.
Each time dup re ads a line of inp ut, the line is used as a key int o the map and the cor-
resp onding value is increment ed. The statement counts[input.Text()]++ is equivalent to
thes e two statements:
line := input.Text()
counts[line] = counts[line] + 1
It’s not a pro blem if the map doesn’t yet cont ain that key. The firs t time a new line is seen, the
expression counts[line] on the rig ht-hand side evaluates to the zero value for its typ e, which
is 0 for int .
To print the results, we use another range -b ased for lo op, this time over the counts map. As
before , each iterat ion pro duces two results, a key and the value of the map element for that
ke y. The order of map iterat ion is not specified, but in prac tice it is random, varying fro m on e
run to another. This desig n is int ent ion al, since it pre vents programs fro m re lying on any par-
ticular order ing where non e is guarante e d.
Onward to the bufio package, which helps make inp ut and out put efficient and convenient.
One of its most useful features is a typ e called Scanner that reads inp ut and bre aks it int o lines
or words; it’s often the easiest way to pro cess inp ut that com es natural ly in lines.
The program uses a short var iable decl arat ion to cre ate a new var iable input that refers to a
bufio.Scanner :
input := bufio.NewScanner(os.Stdin)10
CHAPTER 1.
TUTORIAL
The scanner reads fro m the program’s stand ard inp ut. Each cal l to input.Scan() re ads the
next line and remov es the newline charac ter fro m the end; the result can be ret rie ved by cal l-
ing input.Text() . The Scan func tion retur ns true if there is a line and false when there is
no more inp ut.
The function fmt.Printf , like printf in C and other langu ages, pro duces for matte d output
from a list of expressions. Its firs t argument is a for mat str ing that specifies how subsequent
arguments should be for matte d. The for mat of each argument is deter mined by a conversion
ch arac ter, a letter fol low ing a percent sig n. Fo r example, %d formats an integer operand using
de cimal not ation, and %s exp ands to the value of a str ing operand.
Printf has over a dozen such conversions, which Go programmers cal l verb s. This table is far
from a complete specification but illustrates many of the features that are avai lable:
%d
de cimal integer
%x, %o, %b integer in hexade cimal, octal, binar y
%f, %g, %e floating-p oint number: 3.141593 3.141592653589793 3.141593e+00
%t
boole an: true or false
%c
rune (Unico de co de point)
%s
st ring
%q
quot ed str ing "abc" or rune 'c'
%v
any value in a natural for mat
%T
type of any value
%%
literal percent sig n (no operand)
The for mat str ing in dup1 also contains a tab \t and a newline \n . Str ing lit erals may cont ain
such es cap e sequ ences for represent ing other wis e invisible charac ters. Printf do es not write a
ne wline by defau lt. By convent ion, for matting functions whose names end in f , such as
log.Printf and fmt.Errorf , use the for matting rules of fmt.Printf , where as those whose
names end in ln fo llow Println , for matting their arguments as if by %v , fol low ed by a
ne wline.
Many programs read eit her fro m their stand ard inp ut, as abov e, or fro m a sequence of named
files. The next version of dup can read fro m the stand ard inp ut or handle a list of file names,
using os.Open to open each one:
gopl.io/ch1/dup2
// Dup2 prints the count and text of lines that appear more than once
// in the input. It reads from stdin or from a list of named files.
package main
import (
"bufio"
"fmt"
"os"
)
func main() {
counts := make(map[string]int)
files := os.Args[1:]
if len(files) == 0 {
countLines(os.Stdin, counts)
} else {
for _, arg := range files {
f, err := os.Open(arg)
if err != nil {
fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
continue
}
countLines(f, counts)
f.Close()
}
}
for line, n := range counts {
if n > 1 {
fmt.Printf("%d\t%s\n", n, line)
}
}
}
func countLines(f *os.File, counts map[string]int) {
input := bufio.NewScanner(f)
for input.Scan() {
counts[input.Text()]++
}
// NOTE: ignoring potential errors from input.Err()
}
The function os.Open returns two values. The firs t is an open file ( *os.File ) that is used in
su bsequent reads by the Scanner .
The secon d resu lt of os.Open is a value of the bui lt-in error type. If err equals the speci al
built-in value nil , the file was opene d successf ully. The file is read, and when the end of the
input is reach ed, Close clos es the file and releases any res ources. On the other hand, if err is
not nil , som ething went wro ng. In that cas e, the error value descr ibes the pro blem. Our sim-
ple-minde d er ror handling prints a message on the stand ard error stream using Fprintf and
the verb %v , which displ ays a value of any typ e in a default for mat, and dup then car r ies on
with the next file; the continue st atement goes to the next iterat ion of the enclosing for lo op.
In the int erests of keeping code samples to a reasonable size, our early examples are int ent ion-
al ly som ewhat cavalier about error handling. Cle arly we must che ck for an error fro m
os.Open ; how ever, we are ignor ing the less likely possibi lit y that an erro r could occ ur while
re ading the file wit h input.Scan . We will not e pl aces where we’ve skipp ed error che cking ,
and we will go int o the det ails of error handling in Sec tion 5.4.
No tice that the cal l to countLines precedes its decl arat ion. Functions and other package-le vel
entities may be declare d in any order.12
CHAPTER 1.
TUTORIAL
A map is a reference to the dat a st ruc ture cre ate d by make . When a map is passed to a func-
tion, the function receives a copy of the reference, so any changes the cal le d func tion makes to
the underly ing dat a st ruc ture will be visible through the cal ler’s map reference too. In our
example, the values inserted int o the counts map by countLines are seen by main .
The versions of dup ab ove operate in a ‘‘st reaming’’ mo de in which inp ut is read and bro ken
into lines as needed, so in princip le these programs can handle an arbit rar y amount of inp ut.
An alt ernat ive appro ach is to read the ent ire inp ut int o memory in one big gulp, split it int o
lines all at once, then pro cess the lines. The fol low ing version, dup3 , operates in that fashion.
It int roduces the function ReadFile (f rom the io/ioutil package), which reads the ent ire
cont ents of a name d file, and strings.Split , which splits a str ing int o a slice of subst rings.
( Split is the opp osite of strings.Join , which we saw earlier.)
We’ve simplified dup3 some what. First, it only reads name d files, not the stand ard inp ut, since
ReadFile re quires a file name argument. Secon d, we mov ed the count ing of the lines back
into main , since it is now needed in only one place.
gopl.io/ch1/dup3
package main
import (
"fmt"
"io/ioutil"
"os"
"strings"
)
func main() {
counts := make(map[string]int)
for _, filename := range os.Args[1:] {
data, err := ioutil.ReadFile(filename)
if err != nil {
fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
continue
}
for _, line := range strings.Split(string(data), "\n") {
counts[line]++
}
}
for line, n := range counts {
if n > 1 {
fmt.Printf("%d\t%s\n", n, line)
}
}
}
ReadFile returns a byte slice that must be converted int o a string so it can be split by
strings.Split . We will dis cuss str ings and byte slices at lengt h in Sec tion 3.5.4.
Un der the cov ers, bufio.Scanner , ioutil.ReadFile , and ioutil.WriteFile us e the Read
and Write methods of *os.File , but it’s rare that most programmers need to access those
lower-le vel routines direc tly. The hig her-le vel functions like those fro m bufio and io/ioutil
are easier to use.
Exercis e 1.4: Mo dif y dup2 to print the names of all files in which each dup lic ated line occ urs.
1.4. Animated GIFs
The next program demon strates basic usage of Go’s stand ard image packages, which we’ll use
to cre ate a sequence of bit-mapped images and then encode the sequence as a GIF animat ion.
The images, cal le d Li ssajous figure s, were a staple visual effec t in sci-fi films of the 1960s. They
are the paramet ric cur ves pro duce d by har monic osci l lat ion in two dimensions, such as two
sine waves fed int o the x and y inputs of an oscillos cope. Figure 1.1 shows som e examples.
Figure 1.1. Fo ur Lissajous figures.
There are several new con str ucts in this code, including const de clarat ions, str uct typ es, and
comp osite lit erals. Unlike most of our examples, this one als o invo l ves floating-p oint com-
putation s. We’ll dis cuss these topics only briefly here, pushing most det ails off to later chap-
ters, since the primary goal rig ht now is to give you an ide a of what Go looks like and the
kind s of things that can be don e easi ly wit h the langu age and its librar ies.
gopl.io/ch1/lissajous
// Lissajous generates GIF animations of random Lissajous figures.
package main
import (
"image"
"image/color"
"image/gif"
"io"
"math"
"math/rand"
"os"
)14
CHAPTER 1.
TUTORIAL
var palette = []color.Color{color.White, color.Black}
const (
whiteIndex = 0 // first color in palette
blackIndex = 1 // next color in palette
)
func main() {
lissajous(os.Stdout)
}
func lissajous(out io.Writer) {
const (
cycles = 5
// number of complete x oscillator revolutions
res
= 0.001 // angular resolution
size
= 100
// image canvas covers [-size..+size]
nframes = 64
// number of animation frames
delay
= 8
// delay between frames in 10ms units
)
freq := rand.Float64() * 3.0 // relative frequency of y oscillator
anim := gif.GIF{LoopCount: nframes}
phase := 0.0 // phase difference
for i := 0; i < nframes; i++ {
rect := image.Rect(0, 0, 2*size+1, 2*size+1)
img := image.NewPaletted(rect, palette)
for t := 0.0; t < cycles*2*math.Pi; t += res {
x := math.Sin(t)
y := math.Sin(t*freq + phase)
img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
blackIndex)
}
phase += 0.1
anim.Delay = append(anim.Delay, delay)
anim.Image = append(anim.Image, img)
}
gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}
Af ter importing a package whose pat h has multiple components, like image/color , we refer
to the package wit h a name that com es fro m the last component. Thu s the var iable
color.White belongs to the image/color package and gif.GIF belongs to image/gif .
A const de clarat ion (§3.6) gives names to con stants, that is, values that are fixe d at comp ile
time, such as the numer ical parameters for cyc les, frames, and del ay. Like var de clarat ions,
const de clarat ions may appear at package level (so the names are visible throughout the pack-
age) or wit hin a function (so the names are visible only wit hin that function). The value of a
cons tant must be a number, str ing , or boole an.
The expressions []color.Color{...} and gif.GIF{...} are comp osite lit era ls (§4.2, §4.4.1),
a compact not ation for ins tantiat ing any of Go’s composite typ es from a sequence of element
values. Here, the firs t on e is a slice and the secon d on e is a st ruc t.
The typ e gif.GIF is a str uct typ e (§4.4). A st ruc t is a gro up of values cal le d fiel ds, often of dif-
ferent typ es, that are col lec ted toget her in a single obj e ct that can be tre ate d as a unit. The
var iable anim is a str uct of typ e gif.GIF . The str uct lit eral creates a str uct value whose Loop-
Count field is set to nframes ; all other fields have the zero value for their typ e. The indiv idu al
fields of a str uct can be accessed using dot not ation, as in the final two assig nments which
explicitly update the Delay and Image fields of anim .
The lissajous func tion has two neste d lo ops. The out er loop runs for 64 iterat ions, each
producing a single frame of the animat ion. It cre ates a new 201 & 201 image wit h a palette of
two color s, white and black. All pixel s are initial ly set to the palette’s zero value (the zerot h
color in the palette), which we set to white. Each pass through the inner loop generates a new
image by setting som e pixe ls to black. The result is app ended, using the bui lt-in append func-
tion (§4.2.1), to a list of frames in anim , along wit h a specified del ay of 80ms. Final ly the
sequence of frames and del ays is encoded int o GIF for mat and writt en to the out put stream
out . The typ e of out is io.Writer , which lets us write to a wide range of possible destina-
tion s, as we’ll show soon.
The inner loop runs the two oscillator s. The x os cillator is just the sine function. The y os cil-
lator is als o a sinus oid, but its fre quency rel ative to the x os cillator is a random number
between 0 and 3, and its phase rel ative to the x os cillator is initial ly zero but incre ases wit h
each frame of the animat ion. The loop runs unt i l the x os cillator has comp leted five full
cycles. At each step, it cal ls SetColorIndex to color the pixel cor responding to (x, y) black,
which is at position 1 in the palette.
The main func tion cal ls the lissajous func tion, direc ting it to write to the stand ard out put,
so this command pro duces an animated GIF wit h frames like those in Figure 1.1:
$ go build gopl.io/ch1/lissajous
$ ./lissajous >out.gif
Exercis e 1.5: Change the Lissajous program’s color palette to gre en on black, for adde d
authenticity. To cre ate the web color #RRGGBB , use color.RGBA{0xRR, 0xGG, 0xBB, 0xff} ,
where each pair of hexade cimal digits represents the int ensit y of the red, gre en, or blue com-
ponent of the pixel.
Exercis e 1.6: Mo dif y the Lissajous program to pro duce images in multiple color s by adding
more values to palette and then displ aying them by chang ing the third argument of Set-
ColorIndex in som e interest ing way.
1.5. Fet ching a URL
Fo r many app lic ations, access to infor mat ion fro m the Int ernet is as imp ortant as access to the
lo cal file system. Go provides a collec tion of packages, gro uped under net , that make it easy
to send and receive infor mat ion through the Int ernet, make low-le vel networ k connec tion s,
and set up ser vers, for which Go’s con cur rency features (introduce d in Chapt er 8) are par tic u-
larly useful.16
CHAPTER 1.
TUTORIAL
To illustrate the minimum necessary to ret rie ve infor mat ion over HTTP, here’s a simple
prog ram called fetch that fetch es the content of each specified URL and prints it as uninter-
preted text; it’s ins pired by the invaluable utilit y curl . Obv iou sly one wou ld usu ally do more
with such dat a, but this shows the basic idea. We will use this program fre quently in the book.
gopl.io/ch1/fetch
// Fetch prints the content found at a URL.
package main
import (
"fmt"
"io/ioutil"
"net/http"
"os"
)
func main() {
for _, url := range os.Args[1:] {
resp, err := http.Get(url)
if err != nil {
fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
os.Exit(1)
}
b, err := ioutil.ReadAll(resp.Body)
resp.Body.Close()
if err != nil {
fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
os.Exit(1)
}
fmt.Printf("%s", b)
}
}
This program introduces functions fro m two packages, net/http and io/ioutil . The
http.Get func tion makes an HTTP request and, if there is no error, retur ns the result in the
resp ons e st ruc t resp . The Body field of resp cont ains the ser ver respons e as a readable
st ream. Next, ioutil.ReadAll re ads the ent ire resp ons e; the result is store d in b . The Body
st ream is clos ed to avoid leak ing res ources, and Printf wr ites the respons e to the stand ard
output.
$ go build gopl.io/ch1/fetch
$ ./fetch http://gopl.io
<html>
<head>
<title>The Go Programming Language</title>
...
If the HTTP request fai ls, fetch reports the fai lure ins tead:
$ ./fetch http://bad.gopl.io
fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
In eit her erro r case, os.Exit(1) caus es the pro cess to exit wit h a statu s co de of 1.
Exercis e 1.7: The function cal l io.Copy(dst, src) re ads fro m src and writes to dst . Use it
instead of ioutil.ReadAll to copy the respons e body to os.Stdout without requir ing a
buffer large enoug h to hold the ent ire stream. Be sure to che ck the error result of io.Copy .
Exercis e 1.8: Mo dif y fetch to add the prefix http:// to each argument URL if it is missing.
Yo u mig ht want to use strings.HasPrefix .
Exercis e 1.9: Mo dif y fetch to als o pr int the HTTP statu s co de, found in resp.Status .
1.6. Fet ching URLs Concurrently
One of the most int erest ing and nove l aspects of Go is its sup por t for con cur rent program-
ming. This is a large topic, to which Chapt er 8 and Chapt er 9 are devot ed, so for now we’ll
give you just a taste of Go’s main conc urrency mechanisms, goroutines and channel s.
The next program, fetchall , does the same fetch of a URL’s contents as the pre vious example,
but it fetch es many URLs, all con cur rently, so that the pro cess will take no lon g er than the
longest fetch rat her than the sum of all the fetch times. This version of fetchall discards the
resp ons es but rep orts the size and elaps ed time for each one:
gopl.io/ch1/fetchall
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main
import (
"fmt"
"io"
"io/ioutil"
"net/http"
"os"
"time"
)
func main() {
start := time.Now()
ch := make(chan string)
for _, url := range os.Args[1:] {
go fetch(url, ch) // start a goroutine
}
for range os.Args[1:] {
fmt.Println(<-ch) // receive from channel ch
}
fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}18
CHAPTER 1.
TUTORIAL
func fetch(url string, ch chan<- string) {
start := time.Now()
resp, err := http.Get(url)
if err != nil {
ch <- fmt.Sprint(err) // send to channel ch
return
}
nbytes, err := io.Copy(ioutil.Discard, resp.Body)
resp.Body.Close() // don't leak resources
if err != nil {
ch <- fmt.Sprintf("while reading %s: %v", url, err)
return
}
secs := time.Since(start).Seconds()
ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
Here’s an example:
$ go build gopl.io/ch1/fetchall
$ ./fetchall https://golang.org http://gopl.io https://godoc.org
0.14s
6852 https://godoc.org
0.16s
7261 https://golang.org
0.48s
2475 http://gopl.io
0.48s elapsed
A goro utine is a con cur rent function exe cut ion. A ch ann el is a communic ation mechanism
that allows one goroutine to pass values of a specified typ e to another goroutine. The function
main runs in a goroutine and the go st atement cre ates addition al goroutines.
The main func tion cre ates a channel of str ings using make . For each command-line argument,
the go st atement in the firs t range loop starts a new goroutine that cal ls fetch asy nchro nou sly
to fetch the URL using http.Get . The io.Copy func tion reads the body of the respons e and
discards it by writing to the ioutil.Discard output stream. Copy returns the byte count,
along wit h any error that occ urre d. As each result arrives, fetch send s a summar y line on the
ch annel ch . The secon d range loop in main re ceives and prints those lines.
Wh en one goroutine att emp ts a send or receive on a channel, it blo cks until another goroutine
attemp ts the cor responding receive or send operat ion, at which point the value is transfer red
and bot h goro utines pro ceed. In this example, each fetch send s a value ( ch <- expre ssi on) on
the channel ch , and main re ceives all of them ( <-ch ). Hav ing main do all the print ing ens ures
that out put fro m each goroutine is pro cessed as a unit, wit h no danger of int erleaving if two
goro utines finish at the same time.
Exercis e 1.10: Find a web sit e that pro duces a large amount of dat a. Invest igate caching by
running fetchall twice in succession to see whether the rep orted time changes much. Do
you get the same content each time? Modif y fetchall to print its out put to a file so it can be
examined.
Exercis e 1.11: Tr y fetchall with lon g er argument lists, such as samples fro m the top million
we b sites avai lable at alexa.com . How does the program beh ave if a we b site just doesn’t
resp ond? (Section 8.9 descr ibes mechanisms for coping in such cas es.)
1.7. A Web Server
Go’s librar ies makes it easy to write a web ser ver that respond s to client requests like those
made by fetch . In this sec tion, we’ll show a minimal ser ver that retur ns the pat h comp onent
of the URL used to access the ser ver. That is, if the request is for http://local-
host:8000/hello , the respons e wi l l be URL.Path = "/hello" .
gopl.io/ch1/server1
// Server1 is a minimal "echo" server.
package main
import (
"fmt"
"log"
"net/http"
)
func main() {
http.HandleFunc("/", handler) // each request calls handler
log.Fatal(http.ListenAndServe("localhost:8000", nil))
}
// handler echoes the Path component of the request URL r.
func handler(w http.ResponseWriter, r *http.Request) {
fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
The program is only a handf ul of lines long because librar y func tions do most of the wor k.
The main func tion conne cts a handler function to incoming URLs that beg in with / , which is
al l URLs, and starts a ser ver listening for incoming requests on por t 8000. A re quest is rep-
resent ed as a str uct of typ e http.Request , which contains a number of rel ate d fields, one of
which is the URL of the incoming request. When a request arrives, it is given to the handler
func tion, which ext racts the pat h comp onent ( /hello ) fro m the request URL and sends it
back as the respons e, using fmt.Fprintf . Web ser vers will be explained in det ail in
Section 7.7.
Let’s start the ser ver in the backg round. On Mac OS X or Linux, add an ampers and ( & ) to the
command; on Micros oft Windows, you will need to run the command wit hout the amp ers and
in a sep arate command window.
$ go run src/gopl.io/ch1/server1/main.go &
We can then make client requests fro m the command line:20
CHAPTER 1.
TUTORIAL
$ go build gopl.io/ch1/fetch
$ ./fetch http://localhost:8000
URL.Path = "/"
$ ./fetch http://localhost:8000/help
URL.Path = "/help"
Alternat ive ly, we can access the ser ver fro m a web brows er, as shown in Figure 1.2.
Figure 1.2. A respons e from the ech o server.
It’s easy to add features to the ser ver. One useful addition is a specific URL that retur ns a
st atu s of som e sort. For example, this version does the same ech o but als o counts the number
of requests; a request to the URL /count returns the count so far, exc luding /count re quests
themselves:
gopl.io/ch1/server2
// Server2 is a minimal "echo" and counter server.
package main
import (
"fmt"
"log"
"net/http"
"sync"
)
var mu sync.Mutex
var count int
func main() {
http.HandleFunc("/", handler)
http.HandleFunc("/count", counter)
log.Fatal(http.ListenAndServe("localhost:8000", nil))
}
// handler echoes the Path component of the requested URL.
func handler(w http.ResponseWriter, r *http.Request) {
mu.Lock()
count++
mu.Unlock()
fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
// counter echoes the number of calls so far.
func counter(w http.ResponseWriter, r *http.Request) {
mu.Lock()
fmt.Fprintf(w, "Count %d\n", count)
mu.Unlock()
}
The ser ver has two handlers, and the request URL deter mines which one is cal le d: a request
for /count invo kes counter and all others inv oke handler . A hand ler pattern that ends wit h
a slash match es any URL that has the pattern as a prefix. Behind the scenes, the ser ver runs
the handler for each incoming request in a sep arate goroutine so that it can ser ve multiple
re quests simultane ously. How ever, if two con cur rent requests try to update count at the same
time, it mig ht not be increment ed con sistent ly; the program wou ld have a ser ious bug cal le d a
ra c e condit ion (§9.1). To avoid this pro blem, we must ens ure that at most one goroutine
accesses the var iable at a time, which is the pur pos e of the mu.Lock() and mu.Unlock() calls
that bracket each access of count . We’ll look more clos ely at con cur rency wit h sh are d var i-
ables in Chapt er 9.
As a richer example, the handler function can rep ort on the headers and for m data that it
re ceives, mak ing the ser ver useful for ins pec ting and debug ging requests:
gopl.io/ch1/server3
// handler echoes the HTTP request.
func handler(w http.ResponseWriter, r *http.Request) {
fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
for k, v := range r.Header {
fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
}
fmt.Fprintf(w, "Host = %q\n", r.Host)
fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
if err := r.ParseForm(); err != nil {
log.Print(err)
}
for k, v := range r.Form {
fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
}
}
This uses the fields of the http.Request st ruc t to pro duce out put like this:
GET /?q=query HTTP/1.1
Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
Header["Accept-Language"] = ["en-US,en;q=0.8"]
Header["Connection"] = ["keep-alive"]
Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
Host = "localhost:8000"
RemoteAddr = "127.0.0.1:59911"
Form["q"] = ["query"]22
CHAPTER 1.
TUTORIAL
No tice how the cal l to ParseForm is neste d within an if st atement. Go allows a simple state-
ment such as a local variable declarat ion to pre cede the if condit ion, which is par tic ularly
us eful for error handling as in this example. We cou ld have writt en it as
err := r.ParseForm()
if err != nil {
log.Print(err)
}
but com bining the statements is shorter and reduces the scope of the var iable err , which is
go o d prac tice. We’ll define scope in Sec tion 2.7.
In these programs, we’ve seen three ver y dif ferent typ es us ed as out put streams. The fetch
prog ram copied HTTP respons e data to os.Stdout , a file, as did the lissajous prog ram.
The fetchall prog ram thre w the respons e away (whi le counting its lengt h) by copying it to
the trivial sin k ioutil.Discard . And the web ser ver abov e us ed fmt.Fprintf to write to an
http.ResponseWriter repres enting the web brows er.
Although these three typ es dif fer in the det ails of what the y do, the y al l satisf y a common
interface, allow ing any of them to be used where ver an out put stream is needed. That int er-
face, cal le d io.Writer , is dis cussed in Sec tion 7.1.
Go’s int erface mechanism is the topic of Chapt er 7, but to give an ide a of what it’s cap able of,
let’s see how easy it is to com bine the web ser ver wit h the lissajous func tion so that ani-
mate d GIFs are writt en not to the stand ard out put, but to the HTTP client. Just add these
lines to the web ser ver :
handler := func(w http.ResponseWriter, r *http.Request) {
lissajous(w)
}
http.HandleFunc("/", handler)
or equivalently:
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
lissajous(w)
})
The secon d argument to the HandleFunc func tion cal l immediate ly above is a func tion lit era l,
that is, an anonymou s func tion define d at its point of use. We will explain it fur ther in
Section 5.6.
Once you’ve made this change , visit http://localhost:8000 in your brows er. Each time you
lo ad the page, you’ll see a new animat ion like the one in Figure 1.3.
Exercis e 1.12: Mo dif y the Lissajous ser ver to read parameter values fro m the URL. For exam-
ple, you mig ht arrange it so that a URL like http://localhost:8000/?cycles=20 sets the
numb er of cyc les to 20 ins tead of the defau lt 5. Use the strconv.Atoi func tion to convert the
st ring parameter into an int eger. You can see its document ation wit h go doc strconv.Atoi .
Figure 1.3. Animated Lissajous figures in a brows er.
1.8. Loose Ends
There is a lot more to Go than we’ve cov ere d in this quick int roduc tion. Here are som e topics
we’ve barely touch ed upon or omitt ed ent ire ly, wit h ju st enoug h discussion that the y wi l l be
fami liar when the y make brief appearances before the full treatment.
Contro l flow : We cov ere d the two fundament al control-flow statements, if and for , but not
the switch st atement, which is a multi-way branch. Here’s a small example:
switch coinflip() {
case "heads":
heads++
case "tails":
tails++
default:
fmt.Println("landed on edge!")
}
The result of cal ling coinflip is compare d to the value of each cas e. Cas es are evaluate d from
top to bot tom, so the firs t matching one is exe cut ed. The opt ion al defau lt cas e match es if non e
of the other cas es do es; it may be place d anywhere . Cases do not fal l thro ugh fro m on e to the
next as in C-like langu ages (thoug h there is a rarely used fallthrough st atement that over-
rides this beh avior).
A switch do es not need an operand; it can just list the cas es, each of which is a boole an
expression:24
CHAPTER 1.
TUTORIAL
func Signum(x int) int {
switch {
case x > 0:
return +1
default:
return 0
case x < 0:
return -1
}
}
This for m is cal le d a tagless switch; it’s equivalent to switch true .
Like the for and if st atements, a switch may include an opt ion al simple statement—a short
var iable decl arat ion, an increment or assig nment statement, or a function cal l—that can be
us ed to set a value before it is teste d.
The break and continue st atements modif y the flow of control . A break caus es control to
resume at the next statement after the inner most for , switch , or select st atement (which
we’ll see later), and as we saw in Sec tion 1.3, a continue caus es the inner most for lo op to
st art its next iterat ion. Statements may be lab ele d so that break and continue can refer to
them, for ins tance to bre ak out of several neste d lo ops at once or to start the next iterat ion of
the out ermost loop. There is even a goto st atement, thoug h it’s int ended for machine-gener-
ated code, not regu lar use by programmers.
Na med types: A type de clarat ion makes it possible to give a name to an exist ing typ e. Since
st ruc t types are often long , they are nearly always named. A fami liar example is the definition
of a Point type for a 2-D graphics system:
type Point struct {
X, Y int
}
var p Point
Type declarat ions and named typ es are cov ere d in Chapt er 2.
Po int ers: Go provides point ers, that is, values that contain the address of a var iable. In som e
languages, not ably C, point ers are relative ly uncon strained. In other langu ages, point ers are
disguised as ‘‘references, ’’ and there’s not much that can be don e with them except pass them
around. Go takes a position som ewhere in the midd le. Point ers are explicitly visible. The &
op erator yields the address of a var iable, and the * op erator ret rie ves the var iable that the
pointer refers to, but there is no point er arithmetic. We’ll explain point ers in Sec tion 2.3.2.
Me thods and inte rfa ces: A met hod is a function ass oci ated wit h a named typ e; Go is unu sual
in that met hods may be att ach ed to almost any named typ e. Met hods are cov ere d in Chap-
ter 6. Int erfaces are abstrac t types that let us tre at dif ferent con crete typ es in the same way
based on what met hods the y have , not how the y are represent ed or imp lemente d. Interfaces
are the subjec t of Chapt er 7.
Pa ckage s: Go com es wit h an extensive stand ard librar y of useful packages, and the Go com-
munity has create d and share d many more. Programming is often more about using exist ing
packages than about writing original code of one’s own. Throughout the book, we will point
out a couple of dozen of the most imp ortant stand ard packages, but there are many more we
don’t have space to mention, and we cannot provide anyt hing remot ely like a complete refer-
ence for any package.
Before you emb ark on any new program, it’s a good ide a to see if packages already exist that
mig ht help you get your job don e more easi ly. You can find an index of the stand ard librar y
packages at https://golang.org/pkg and the packages cont ribut ed by the community at
https://godoc.org . The go doc to ol makes these documents easi ly accessible fro m the
command line:
$ go doc http.ListenAndServe
package http // import "net/http"
func ListenAndServe(addr string, handler Handler) error
ListenAndServe listens on the TCP network address addr and then
calls Serve with handler to handle requests on incoming connections.
...
Comm ents: We have already mention ed documentation comments at the beg inning of a
prog ram or package. It’s als o go o d st yle to write a comment before the declarat ion of each
func tion to specif y its beh avior. These convent ion s are imp ortant, because the y are used by
to ols like go doc and godoc to locate and displ ay documentation (§10.7.4).
Fo r comments that span multiple lines or app ear wit hin an expression or statement, there is
also the /* ... */ notation fami liar fro m ot her langu ages. Such comments are som etimes
us ed at the beg inning of a file for a large blo ck of explanatory text to avoid a // on every line.
Wi thin a comment, // and /* have no speci al me aning, so comments do not nest.
